{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/__mods/FlagManager.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\n//in order for the linter to work, it must access an actual valid file\nimport 'infinitymint/alpha/ERC721.sol'; //all of these will be remapped by Initial to point to where the file actually is\nimport 'infinitymint/alpha/InfinityMint.sol';\n\ncontract Mod_FlagManager is Authentication, InfinityMintObject {\n    InfinityMint erc721;\n    InfinityMintStorage storageController;\n\n    event OptionUpdated(string option, address indexed sender, string newValue);\n\n    event FlagUpdated(\n        string flag,\n        uint256 tokenId,\n        address indexed sender,\n        bool oldValue,\n        bool newValue\n    );\n\n    constructor(address erc721Destination, address storageDestination) {\n        erc721 = InfinityMint(erc721Destination);\n        storageController = InfinityMintStorage(storageDestination);\n    }\n\n    function getTokenFlag(\n        address addr,\n        uint256 tokenId,\n        string memory optionKey\n    ) external view returns (string memory) {\n        string memory key = InfinityMintUtil.toString(tokenId);\n        return storageController.getOption(addr, string.concat(key, optionKey));\n    }\n\n    function setTokenFlag(\n        uint256 tokenId,\n        string memory optionKey,\n        string memory optionValue\n    ) public {\n        require(erc721.isApprovedOrOwner(sender(), tokenId));\n        string memory key = InfinityMintUtil.toString(tokenId);\n\n        storageController.setOption(\n            sender(),\n            string.concat(key, optionKey),\n            optionValue\n        );\n        emit OptionUpdated(\n            string.concat(key, optionKey),\n            sender(),\n            optionValue\n        );\n    }\n}\n"
    },
    "contracts/__mods/Marketplace.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport 'infinitymint/alpha/InfinityMint.sol';\nimport 'infinitymint/alpha/InfinityMintApi.sol';\nimport 'infinitymint/alpha/IERC721.sol';\n\ncontract Mod_Marketplace is InfinityMintObject {\n    address infinityMint;\n\n    struct OfferObject {\n        address sender;\n        uint256 tokenId;\n        uint256 value;\n    }\n\n    struct TransferObject {\n        uint256 tokenId;\n        address from;\n        address to;\n        uint256 value;\n        bool hasTransfer;\n    }\n\n    uint256 internal executionCount;\n\n    mapping(uint32 => mapping(address => OfferObject)) internal tokenOffers;\n    mapping(uint32 => address[]) public userOffers;\n    mapping(uint32 => TransferObject) internal transfers;\n\n    event Offer(address indexed sender, uint32 tokenId, uint256 amount);\n    event AwaitingTransfer(address indexed sender, TransferObject);\n    event TransferConfirmed(\n        address indexed sender,\n        uint256 tokenId,\n        address to,\n        uint256 amount\n    );\n\n    modifier onlyOnce() {\n        executionCount += 1;\n        uint256 localCounter = executionCount;\n        _;\n        require(localCounter == executionCount);\n    }\n\n    constructor(address _infinityMint) {\n        if (!isContract(_infinityMint)) revert('Must be NFT contract address');\n\n        infinityMint = _infinityMint;\n    }\n\n    function getOffers(uint32 tokenId) public view returns (address[] memory) {\n        return userOffers[tokenId];\n    }\n\n    ///@notice Returns true if the address is a contract\n    ///@dev Sometimes doesnt work and contracts might be disgused as addresses\n    function isContract(address _address) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(_address)\n        }\n        return size > 0;\n    }\n\n    function getOffer(uint32 tokenId, address offerSender)\n        public\n        view\n        returns (OfferObject memory)\n    {\n        return tokenOffers[tokenId][offerSender];\n    }\n\n    function awaitingTransfer(uint32 tokenId) public view returns (bool) {\n        return (transfers[tokenId].to != address(0x0) &&\n            transfers[tokenId].hasTransfer != true);\n    }\n\n    function awaitingTransferTo(uint32 tokenId) public view returns (address) {\n        return transfers[tokenId].to;\n    }\n\n    function ownerOf(uint32 tokenId) public returns (address) {\n        (bool success, bytes memory result) = address(infinityMint).call(\n            abi.encodeWithSelector(IERC721.ownerOf.selector, uint256(tokenId))\n        );\n\n        if (!success) return address(0x0);\n\n        return abi.decode(result, (address));\n    }\n\n    function makeOffer(uint32 tokenId) public payable virtual onlyOnce {\n        require(!isContract(sender()), 'Contracts are not allowed');\n        require(msg.value >= 0, 'value less than zero');\n        require(ownerOf(tokenId) != address(0x0), 'Invalid Token');\n        require(\n            ownerOf(tokenId) != sender(),\n            'Cannot make offers on your own token'\n        );\n        require(\n            tokenOffers[tokenId][sender()].sender == address(0x0),\n            'You already have an offer open'\n        );\n        require(\n            transfers[tokenId].to == address(0x0),\n            'This token has already been sold and is waiting to be transfered'\n        );\n\n        tokenOffers[tokenId][sender()] = OfferObject(\n            sender(),\n            tokenId,\n            msg.value\n        );\n        //add to user offers\n        userOffers[tokenId].push(sender());\n\n        emit Offer(sender(), tokenId, msg.value);\n    }\n\n    function revokeOffer(uint32 tokenId) public virtual onlyOnce {\n        require(!isContract(sender()), 'Contracts are not allowed');\n        require(\n            transfers[tokenId].to != sender(),\n            'you cannot revoke at this time'\n        );\n        require(\n            tokenOffers[tokenId][sender()].sender != address(0x0) &&\n                tokenOffers[tokenId][sender()].sender == sender(),\n            'No offer from this address or incorect sender'\n        );\n\n        //send back the monies\n        payable(sender()).transfer(tokenOffers[tokenId][sender()].value);\n        //delete the offer for the sender\n        delete tokenOffers[tokenId][sender()];\n        //update the user offers array\n        deleteAddress(tokenId, sender());\n    }\n\n    function acceptOffer(uint32 tokenId, address offerSender) public virtual {\n        require(\n            transfers[tokenId].to == address(0x0),\n            'This token has already been sold and is waiting to be transfered'\n        );\n        require(\n            tokenOffers[tokenId][offerSender].sender != address(0x0),\n            'No offer from this address'\n        );\n        require(ownerOf(tokenId) != address(0x0), 'Invalid Token');\n        require(\n            ownerOf(tokenId) == sender(),\n            'You are not the owner of this token'\n        );\n\n        transfers[tokenId] = TransferObject(\n            tokenId,\n            sender(),\n            tokenOffers[tokenId][offerSender].sender,\n            tokenOffers[tokenId][offerSender].value,\n            false\n        );\n\n        emit AwaitingTransfer(sender(), transfers[tokenId]);\n\n        //delete the offer for the sender\n        delete tokenOffers[tokenId][offerSender];\n        //update the user offers array\n        deleteAddress(tokenId, offerSender);\n    }\n\n    function confirmTransfer(uint32 tokenId) public virtual onlyOnce {\n        require(transfers[tokenId].from == sender(), 'not owner');\n        require(\n            transfers[tokenId].hasTransfer == false,\n            'token has already transfered'\n        );\n        require(\n            ownerOf(tokenId) == transfers[tokenId].to,\n            'has not transfered'\n        );\n\n        uint256 value = (transfers[tokenId].value);\n        transfers[tokenId] = TransferObject(\n            tokenId,\n            address(0x0),\n            address(0x0),\n            0,\n            true\n        );\n        payable(sender()).transfer(value);\n    }\n\n    function deleteAddress(uint32 tokenId, address offerSender) internal {\n        if (userOffers[tokenId].length - 1 == 0) {\n            userOffers[tokenId] = new address[](0);\n            return;\n        }\n\n        address[] memory temp = new address[](userOffers[tokenId].length - 1);\n        uint256 count = 0;\n        for (uint256 i = 0; i < userOffers[tokenId].length; i++) {\n            if (userOffers[tokenId][i] == offerSender) continue;\n            temp[count++] = userOffers[tokenId][i];\n        }\n        userOffers[tokenId] = temp;\n    }\n}\n"
    },
    "contracts/__mods/MarketplaceImproved.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport 'infinitymint/alpha/InfinityMint.sol';\nimport 'infinitymint/alpha/InfinityMintApi.sol';\nimport 'infinitymint/alpha/IERC721.sol';\n\ncontract Mod_MarketplaceImproved is InfinityMintObject {}\n"
    },
    "contracts/__mods/MerkleTree.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport 'contracts/Authentication.sol';\nimport 'contracts/IERC721.sol';\n\ncontract Mod_MerkleTree {}\n"
    },
    "contracts/__mods/MultiMinter.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//import erc721\n//simple erc721 with a token URI managed by owner\n//versioned token URI?????\n//will be put into the project\n//0xTinman.eth 2023\npragma solidity ^0.8.0;\n\nimport 'contracts/InfinityMint.sol';\nimport 'contracts/Authentication.sol';\nimport 'contracts/InfinityMintObject.sol';\n\ncontract Mod_MultiMinter is ERC721, Authentication, InfinityMintObject {\n    string public constant version = \"0.69.0\";  // <-- Add a version variable\n    mapping(uint256 => string) public currentTokenUri;\n    uint256 public currentTokenUriIndex;\n    uint256 public tokenId;\n    uint256 public tokenPrice;\n    InfinityMint internal erc721;\n\n    event Mint(address indexed sender, uint256 tokenId, string firstMintedURI);\n\n    /// @notice InfinityMint Constructor takes tokenName and tokenSymbol and the various destinations of controller contracts\n    constructor(\n        string memory tokenName,\n        string memory tokenSymbol,\n        address erc721Destination,\n        uint256 _tokenPrice\n    ) ERC721(tokenName, tokenSymbol) {\n        tokenPrice = _tokenPrice;\n        erc721 = InfinityMint(erc721Destination);\n    }\n\n    //sets the current tokenURI to use in the mints\n    function setCurrentTokenURI(uint256 tokenUriIndex) public onlyApproved {\n        require(\n            bytes(currentTokenUri[tokenUriIndex]).length > 0,\n            'no token uri set here'\n        );\n        currentTokenUriIndex = tokenUriIndex;\n    }\n\n    //sets the token URI that people can mint\n    function setTokenURI(uint256 tokenUriIndex, string memory newTokenURI)\n        public\n        onlyApproved\n    {\n        require(bytes(newTokenURI).length > 0, 'empty token URI');\n        currentTokenUri[tokenUriIndex] = newTokenURI;\n    }\n\n    //set the price of the mint\n    function setPrice(uint256 _tokenPrice) public onlyApproved {\n        tokenPrice = _tokenPrice;\n    }\n\n    function getSelectedTokenURI() external view returns (uint256) {\n        return tokenId;\n    }\n\n    function getCurrentTokenURI() external view returns (string memory) {\n        return currentTokenUri[currentTokenUriIndex];\n    }\n\n    //returns how many mints\n    function totalMints() external view returns (uint256) {\n        return tokenId;\n    }\n\n    //Mints a new ERC721 token, giving it the URI of the current tokenURIIndex\n    function mint() public payable {\n        //checks price is what we have set it too\n        require(\n            value() == tokenPrice || approved[sender()] || sender() == deployer,\n            'bad price'\n        );\n        require(\n            bytes(currentTokenUri[currentTokenUriIndex]).length > 0,\n            'owner has not set up uri'\n        );\n        //deposit the current price of this mint back to the InfinityMint controller\n        erc721.depositSystemRoyalty{ value: value() }(0);\n        //mint a new token to the sender with the current token ID and then send no bytes to their wallet\n        ERC721.mint(sender(), tokenId, bytes('')); // <- third param is sent to contracts/wallets kind of like sharing code, i can put code here that will be passed\n        uri[tokenId] = currentTokenUri[currentTokenUriIndex]; //sets the tokenURI of the token (the look) to be the one which is currently selected by the owner\n        emit Mint(sender(), tokenId++, currentTokenUri[currentTokenUriIndex]);\n    }\n}\n"
    },
    "contracts/__mods/MultiMinterOracle.sol": {
      "content": "//will be put into the project\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\n//InfinityMint authentication system\nimport 'contracts/Authentication.sol';\n\ncontract Mod_MultiMinterOracle is Authentication {\n    mapping(address => bool) public multiMinters;\n\n    function registerMultiMinter(address _multiMinter) public onlyApproved {\n        multiMinters[_multiMinter] = true;\n    }\n\n    function revokeMultiMinter(address _multiMinter) public onlyApproved {\n        multiMinters[_multiMinter] = false;\n    }\n\n    function isMultiMinter(address _multiMinter) public view returns (bool) {\n        return multiMinters[_multiMinter];\n    }\n}\n"
    },
    "contracts/__mods/MultiReceiver.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport 'contracts/InfinityMint.sol';\nimport 'contracts/Authentication.sol';\nimport 'contracts/InfinityMintObject.sol';\nimport 'contracts/IntegrityInterface.sol';\nimport './MultiMinterOracle.sol';\n\ncontract Mod_MultiReceiver is\n    Authentication,\n    IERC721Receiver,\n    InfinityMintObject,\n    IntegrityInterface\n{\n    /// @notice the version type of wallet this is\n    bytes public walletType = 'multiReceiver';\n    /// @notice the location of the main ERC721 contract this wallet was spawned from;\n    address public erc721;\n    /// @notice the main ERC721 contract this wallet is attached too\n    uint32 public currentTokenId;\n    /// @notice the value/balance of the current wallet\n    uint256 private walletValue;\n    /// @notice the interface for the MultiMinterOracle\n    Mod_MultiMinterOracle public multiMinterOracle;\n\n    /// @notice Fired when a deposit is made\n    event Deposit(address indexed sender, uint256 amount, uint256 newTotal);\n    /// @notice Fired with a withdraw is made\n    event Withdraw(address indexed sender, uint256 amount, uint256 newTotal);\n\n    /// @notice Creates new wallet contract, tokenId refers to the ERC721 contract this wallet was spawned from.\n    /// @dev makes the owner field the owner of the contract not the deployer.\n    /// @param tokenId the tokenId from the main ERC721 contract\n    /// @param erc721Destination the main ERC721 contract\n    constructor(\n        uint32 tokenId,\n        address erc721Destination,\n        address multiMinterOracleDestination\n    ) Authentication() {\n        //this only refers to being allowed to deposit into the wallet\n        currentTokenId = tokenId;\n        erc721 = erc721Destination;\n        walletValue = 0;\n        multiMinterOracle = Mod_MultiMinterOracle(multiMinterOracleDestination);\n    }\n\n    /// @notice used by InfinityMintLinker to verify this contract is the one it says\n    function getIntegrity()\n        public\n        view\n        virtual\n        returns (\n            address,\n            address,\n            uint256,\n            bytes memory,\n            bytes4\n        )\n    {\n        return (\n            address(this),\n            deployer,\n            currentTokenId,\n            walletType, //no version type with wallet\n            type(IntegrityInterface).interfaceId\n        );\n    }\n\n    /// @notice Opts in this contract to receipt ERC721 only if that ERC721 is a multiMinter\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external view returns (bytes4) {\n        require(\n            multiMinterOracle.isMultiMinter(sender()),\n            'this wallet can only receive from a multiMinter'\n        );\n\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    /**\n\t\t@notice This can be called by the new token owner at any time and it will match the current owner of the contract to the tokenId,\n\t\tin all cases the wallet will still be attached to the owner of the tokenId and when its not it will simply move over permissions of\n\t\tthe contract to the new owner\n\t */\n    function transferOwnershipToTokenOwner() public onlyOnce {\n        address owner = IERC721(erc721).ownerOf(currentTokenId);\n        require(deployer != owner, 'owner of the token is the deployer');\n        require(msg.sender == owner, 'sender must be the new owner');\n\n        transferOwnership(owner);\n    }\n\n    function transfer(\n        address erc721Destination,\n        address to,\n        uint256 tokenId\n    ) public onlyApproved {\n        (bool success, bytes memory returnData) = erc721Destination.call{\n            value: 0\n        }(\n            abi.encodeWithSignature(\n                'transfer(address,address,uint256)',\n                address(this),\n                address(to),\n                tokenId\n            )\n        );\n\n        if (!success) {\n            if (returnData.length == 0) revert('call reverted');\n            else\n                assembly {\n                    let returndata_size := mload(returnData)\n                    revert(add(32, returnData), returndata_size)\n                }\n        }\n    }\n\n    /// @notice Returns the balance of the wallet\n    function getBalance() public view returns (uint256) {\n        return walletValue;\n    }\n\n    /// @notice Allows anyone to deposit ERC20 into this wallet.\n    function deposit() public payable onlyOnce {\n        uint256 value = (msg.value);\n        require(value >= 0);\n\n        walletValue = walletValue + value;\n        emit Deposit(msg.sender, value, walletValue);\n    }\n\n    /// @notice Allows you to withdraw\n    function withdraw() public onlyOnce onlyApproved {\n        //to stop re-entry attack\n        uint256 balance = (walletValue);\n        walletValue = 0;\n        payable(deployer).transfer(balance);\n        emit Withdraw(msg.sender, address(this).balance, walletValue);\n    }\n}\n"
    },
    "contracts/__mods/Redemption.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0x0zAgency 2023\npragma solidity ^0.8.0;\n\nimport 'contracts/Authentication.sol';\nimport 'contracts/IERC721.sol';\n\ncontract Mod_Redemption is IERC721Receiver, Authentication, InfinityMintObject {\n    string public constant version = \"0.69\";  // <-- Add a version variable\n    IERC721 erc721;\n\n    mapping(uint256 => bytes) private activeRedemptions;\n    mapping(uint256 => Request) private requests;\n    mapping(uint256 => SuccessfulRedemption) private successfulRedemptions;\n    mapping(address => uint256) private requestCount;\n    mapping(address => bool) private blockedWallets;\n\n    struct Request {\n        address sender;\n        bytes redemption;\n        bytes key;\n        bool valid;\n    }\n\n    struct SuccessfulRedemption {\n        address receiver;\n        address admin;\n        uint256 time;\n        uint256 tokenId;\n        bool valid;\n    }\n\n    event RequestSubmitted(uint256 tokenId, address indexed sender);\n    event RequestApproved(\n        uint256 tokenId,\n        address indexed sender,\n        address admin\n    );\n    event RequestRejected(\n        uint256 tokenId,\n        address indexed sender,\n        address admin\n    );\n\n    constructor(address erc721Destination) {\n        erc721 = IERC721(erc721Destination);\n    }\n\n\n\n    function getRequestOwner(uint256 tokenId) public view returns (address) {\n        if (requests[tokenId].valid == false) return address(0x0);\n        return requests[tokenId].sender;\n    }\n\n    function getRequest(uint256 tokenId) public view returns (Request memory) {\n        /*require(\n            approved[sender()] ||\n                deployer == sender() ||\n                getRequestOwner(tokenId) == sender(),\n            'invalid permissions'\n        );*/\n        return requests[tokenId];\n    }\n\n    function getActiveRedemption(uint256 tokenId)\n        public\n        view\n        returns (bytes memory)\n    {\n        require(bytes(activeRedemptions[tokenId]).length != 0, 'invalid active redemption');\n        return activeRedemptions[tokenId];\n    }\n\n    function setWalletBlocked(address addr, bool value) public onlyApproved {\n        blockedWallets[addr] = value;\n    }\n\n    function hasRequest(uint256 tokenId) public view returns (bool) {\n        return requests[tokenId].valid == true;\n    }\n\n    function getRequestCount(address addr)\n        external\n        view\n        onlyApproved\n        returns (uint256)\n    {\n        return requestCount[addr];\n    }\n\n    function getChecks(uint256 tokenId)\n        external\n        view\n        returns (bool[] memory bools)\n    {\n        bools = new bool[](3);\n        bools[0] = this.isRedeemable(tokenId);\n        bools[1] = hasRedeemed(tokenId);\n        bools[2] = hasRequest(tokenId);\n    }\n\n    function getMyRequestCount() external view returns (uint256) {\n        require(sender() != address(0x0));\n        return requestCount[sender()];\n    }\n\n    function isRedeemable(uint256 tokenId) external view returns (bool) {\n        return bytes(activeRedemptions[tokenId]).length != 0;\n    }\n\n    function hasRedeemed(uint256 tokenId) public view returns (bool) {\n        return successfulRedemptions[tokenId].valid;\n    }\n\n    function getRedemptionProof(uint256 tokenId)\n        public\n        view\n        returns (SuccessfulRedemption memory)\n    {\n        require(hasRedeemed(tokenId), 'has not been redeemed');\n        /*require(\n            sender() == successfulRedemptions[tokenId].receiver ||\n                approved[sender()] ||\n                deployer == sender()\n        );*/\n        return successfulRedemptions[tokenId];\n    }\n\n    function makeUnredeemable(uint256 tokenId) public {\n        require(\n            bytes(activeRedemptions[tokenId]).length != 0,\n            'must be redeemable'\n        );\n        require(\n            successfulRedemptions[tokenId].valid == false,\n            'already redeemed cannot change'\n        );\n\n        delete activeRedemptions[tokenId];\n    }\n\n    /// @notice Allows this redemption contract to receive ERC721 from approved addresses only\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external view onlyApproved returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    /// @notice Rejects a request to redeem a token\n    function rejectRedeem(uint256 tokenId) public onlyApproved {\n        require(requests[tokenId].valid, 'invalid request');\n        require(\n            bytes(activeRedemptions[tokenId]).length != 0,\n            'invalid redemption token id'\n        );\n\n        address tempSender = (requests[tokenId].sender);\n        if (requestCount[tempSender] > 0)\n            requestCount[tempSender] = requestCount[tempSender] - 1;\n\n        delete requests[tokenId];\n        emit RequestRejected(tokenId, tempSender, sender());\n    }\n\n    /// @notice Approves a request to redeem a token\n    function approveRedeem(uint256 tokenId, bytes memory redemption)\n        public\n        onlyApproved\n        onlyOnce\n    {\n        //is valid request\n        require(requests[tokenId].valid, 'invalid request');\n        //active redemption valid\n        require(\n            bytes(activeRedemptions[tokenId]).length != 0,\n            'invalid redemption token id'\n        );\n        //has already been redeemed\n        require(\n            successfulRedemptions[tokenId].valid == false,\n            'token has already been redeemed'\n        );\n        //check that the passcode is equal to the activeRedemptions passcode.\n        require(\n            InfinityMintUtil.isEqual(redemption, activeRedemptions[tokenId]),\n            'check failed'\n        );\n        Request memory tempRequest = requests[tokenId];\n        delete requests[tokenId];\n\n        //write to storage\n        successfulRedemptions[tokenId] = SuccessfulRedemption(\n            tempRequest.sender,\n            sender(),\n            block.timestamp,\n            tokenId,\n            true\n        );\n\n        //deduct from request count\n        if (requestCount[requests[tokenId].sender] > 0)\n            requestCount[tempRequest.sender] =\n                requestCount[tempRequest.sender] -\n                1;\n        //transfer the token from this contract to the sender\n        erc721.safeTransferFrom(address(this), tempRequest.sender, tokenId);\n        emit RequestApproved(tokenId, tempRequest.sender, sender());\n    }\n\n    /// @notice Requests a token to be transfered to the sender\n    function requestToken(\n        uint256 tokenId,\n        bytes memory redemption,\n        bytes memory theirKey\n    ) public \n         {\n        \n        require(!isContract(sender()), 'cannot be invoked by contract');\n        require(\n            !blockedWallets[sender()],\n            'cannot redeem a token at this time'\n        );\n        \n        require(\n            requestCount[sender()] <= 3,\n            'you have too many requests open at this time'\n        );\n        \n        require(\n            successfulRedemptions[tokenId].valid == false,\n            'token has already been redeemed'\n        );\n        \n        require(\n            bytes(activeRedemptions[tokenId]).length != 0,\n            'invalid redemption token id'\n        );\n\n        \n        require(\n            requests[tokenId].valid == false,\n            'request already open for this token'\n        );\n        \n        require(\n            bytes(redemption).length != 0,\n            string(redemption)\n        );\n        \n        require(\n            bytes(activeRedemptions[tokenId]).length != 0,\n            string(activeRedemptions[tokenId])\n        );\n        \n        require(\n            InfinityMintUtil.isEqual(redemption, activeRedemptions[tokenId]),\n            string(redemption)\n            //'validation sucks failed'\n        );\n\n        requests[tokenId] = Request(sender(), redemption, theirKey, true);\n        requestCount[sender()] = requestCount[sender()] + 1;\n        emit RequestSubmitted(tokenId, sender());\n    }\n\n    function addRedemption(uint256 tokenId, bytes memory redemption)\n        public\n        onlyApproved\n    {\n        require(bytes(activeRedemptions[tokenId]).length == 0, 'already set');\n        require(\n            erc721.ownerOf(tokenId) == address(this),\n            'please transfer the token to this contract first'\n        );\n\n        activeRedemptions[tokenId] = redemption;\n    }\n\n    function addRedemptions(\n        uint256[] memory _tokenIds,\n        bytes[] memory redemptions\n    ) public onlyApproved {\n        require(_tokenIds.length == redemptions.length, 'mismatch');\n\n        for (uint256 i = 0; i < redemptions.length; ) {\n            uint256 tokenId = _tokenIds[i];\n            activeRedemptions[tokenId] = redemptions[i];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    ///@notice Returns true if the address is a contract\n    ///@dev Sometimes doesnt work and contracts might be disgused as addresses\n    function isContract(address _address) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(_address)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "contracts/__mods/RedemptionLinker.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman 2021\npragma solidity ^0.8.0;\n\nimport 'contracts/ERC721.sol';\nimport 'contracts/InfinityMintLinker.sol';\nimport './Redemption.sol';\n\ncontract Mod_RedemptionLinker is ERC721, Authentication, InfinityMintObject {\n    string forcedUri;\n    Mod_Redemption redemption;\n    InfinityMintLinker linker;\n    ERC721 parent;\n\n    struct ProofOfRedemption {\n        bool valid;\n        uint256 redemptionTokenId;\n        uint256 redeemedToken;\n        address redeemer;\n        uint256 time;\n    }\n\n    struct Map {\n        bool valid;\n        uint256 redemptionTokenId;\n        uint256 parentTokenId;\n    }\n\n    mapping(uint256 => ProofOfRedemption) redemptions;\n    mapping(uint256 => Map) tokenIdTable;\n    uint256 redemptionTokenId;\n\n    constructor(\n        string memory _tokenURI,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        address redemptionDestination,\n        address linkerDestination,\n        address parentERC721\n    ) ERC721(_tokenName, _tokenSymbol) {\n        redemption = Mod_Redemption(redemptionDestination);\n        linker = InfinityMintLinker(linkerDestination);\n        forcedUri = _tokenURI;\n        parent = ERC721(parentERC721);\n        redemptionTokenId = 0;\n    }\n\n    function setForcedTokenURI(string memory uri) public onlyDeployer {\n        forcedUri = uri;\n    }\n\n    function forceMint(address sender) public onlyDeployer {\n        mint(sender, redemptionTokenId, bytes(''));\n        redemptionTokenId = redemptionTokenId + 1;\n    }\n\n    function mintProofOfRedemption(uint256 parentTokenId) public {\n        require(\n            parent.isApprovedOrOwner(sender(), parentTokenId),\n            'sender does not own token'\n        );\n        require(tokenIdTable[parentTokenId].valid == false, 'already redeemed');\n        require(\n            redemption.hasRedeemed(parentTokenId),\n            'has not been redeemed through redemption contract'\n        );\n\n        mint(sender(), redemptionTokenId, bytes(''));\n        \n        // Set the tokenURI of the minted token to the provided file path\n        uri[redemptionTokenId] = \"https://ipfs.io/ipfs/bafybeid6ydc6icfza2zmt46mfjbrewi2dsq5lrmzgpaqqsymzkntlfphrm/partytime_default_proof_uri.json\";\n\n        linker.forceLink(parentTokenId, 'proof_of_redemption', address(this));\n        tokenIdTable[parentTokenId] = Map(\n            true,\n            redemptionTokenId,\n            parentTokenId\n        );\n        redemptions[redemptionTokenId] = ProofOfRedemption(\n            true,\n            redemptionTokenId,\n            parentTokenId,\n            sender(),\n            block.timestamp\n        );\n\n        redemptionTokenId = redemptionTokenId + 1;\n    }\n\n    function canGetProofOfRedemption(uint256 parentTokenId)\n        external\n        view\n        returns (bool)\n    {\n        if (!parent.exists(parentTokenId)) return false;\n\n        return\n            parent.isApprovedOrOwner(sender(), parentTokenId) &&\n            redemption.hasRedeemed(parentTokenId) &&\n            tokenIdTable[parentTokenId].valid == false;\n    }\n\n    function get(uint256 tokenId)\n        external\n        view\n        returns (ProofOfRedemption memory)\n    {\n        return redemptions[tokenId];\n    }\n\n    function getProofOfRedemption(uint256 parentTokenId)\n        external\n        view\n        returns (ProofOfRedemption memory)\n    {\n        require(tokenIdTable[parentTokenId].valid, 'invalid PoR');\n        return (redemptions[tokenIdTable[parentTokenId].redemptionTokenId]);\n    }\n\n    function setTokenURI(uint256 _tokenId, string memory _newURI)\n        public\n        onlyApproved\n    {\n        uri[_tokenId] = _newURI;\n    }\n\n    function tokenURI(uint256 _tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        if (bytes(uri[_tokenId]).length == 0) return forcedUri;\n\n        return uri[_tokenId];\n    }\n}\n"
    },
    "contracts/__mods/SelectiveMint.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport 'contracts/ERC721.sol';\nimport 'contracts/InfinityMint.sol';\nimport 'contracts/InfinityMintAsset.sol';\nimport 'contracts/InfinityMintValues.sol';\nimport 'contracts/Royalty.sol';\nimport 'contracts/Authentication.sol';\n\ncontract Mod_SelectiveMint is Authentication, InfinityMintObject {\n    InfinityMintAsset public assetController;\n    InfinityMint public erc721;\n    RandomNumber public randomNumberController;\n    InfinityMintValues public valuesController;\n    Royalty public royaltyController;\n\n    constructor(\n        address erc721Destination,\n        address assetControllerDestination,\n        address randomNumberControllerDestination,\n        address valuesControllerDestination,\n        address royaltyControllerDestination\n    ) {\n        erc721 = InfinityMint(erc721Destination);\n        assetController = InfinityMintAsset(assetControllerDestination);\n        randomNumberController = RandomNumber(\n            randomNumberControllerDestination\n        );\n        valuesController = InfinityMintValues(valuesControllerDestination);\n        royaltyController = Royalty(royaltyControllerDestination);\n    }\n\n    function balance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function deposit() public onlyDeployer onlyOnce {\n        require(balance() > 0, 'No balance to deposit to main erc721 contract');\n        erc721.depositSystemRoyalty{ value: balance() }(0);\n    }\n\n    function mint(\n        uint32 pathId,\n        uint32[] memory assets,\n        uint256 nameCount\n    ) public payable onlyOnce {\n        require(\n            erc721.approved(sender()) ||\n                erc721.deployer() == sender() ||\n                value() == erc721.tokenPrice(),\n            'Incorrect value'\n        );\n        require(assetController.isValidPath(pathId), 'Invalid Path');\n        uint256[] memory pathSections = assetController.getPathSections(pathId);\n\n        //checks that the asset lenght patches the path section length\n        require(pathSections.length == assets.length, 'Invalid Sections');\n\n        //loops each of the sections and gets the asset for that section and checks if the asset is valid for that section (is in the section)\n        for (uint256 x = 0; x < pathSections.length; ) {\n            uint256 pathSectionId = pathSections[x];\n            uint256[] memory pathAssetIds = assetController.getSectionAssets(\n                pathSectionId\n            );\n            bool found = false;\n\n            for (uint256 y = 0; y < pathAssetIds.length; y++) {\n                if (pathAssetIds[y] == assets[x]) {\n                    found = true;\n                    break;\n                }\n            }\n            require(found, 'Invalid asset');\n            unchecked {\n                x++;\n            }\n        }\n\n        if (nameCount <= 0) nameCount = 1;\n\n        string[] memory names;\n\n        if (!valuesController.isTrue('matchedMode'))\n            names = assetController.getNames(nameCount, randomNumberController);\n        else {\n            names = new string[](2);\n            names[0] = assetController.names(pathId);\n            names[1] = erc721.symbol();\n        }\n\n        uint32[] memory colours = assetController.getColours(\n            pathId,\n            randomNumberController\n        );\n\n        erc721.depositSystemRoyalty{ value: value() }(0);\n        erc721.implicitMint(\n            sender(),\n            pathId,\n            assetController.getPathSize(pathId),\n            colours,\n            bytes(''),\n            assets,\n            names\n        );\n    }\n}\n"
    },
    "contracts/__mods/SimpleWhitelist.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport 'contracts/Authentication.sol';\nimport 'contracts/IERC721.sol';\n\ncontract Mod_SimpleWhitelist {}\n"
    },
    "contracts/ads/EAS.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './../ERC721.sol';\nimport './EASObjects.sol';\nimport './EASContainer.sol';\nimport './EASWallet.sol';\nimport './IEASManager.sol';\nimport './IEASReceiver.sol';\nimport './IEASRegistry.sol';\n\n/**\n\tEach Chain gets an EAS\n */\ncontract EAS is ERC721, EASObjects {\n    EASContainer container;\n\n    uint256 stickerId;\n    uint256 managerId;\n    mapping(uint256 => address) managers;\n    mapping(address => bool) registeredManagers;\n\n    event ManagerRegistered(\n        address indexed sender,\n        address managerDestination,\n        uint256 managerId\n    );\n\n    constructor(address containerDestination)\n        ERC721('Ethereum Ad Service', 'EAS')\n    {\n        container = EASContainer(containerDestination);\n    }\n\n    function registerManager(address managerDestination) public {\n        require(!registeredManagers[managerDestination], 'already registered');\n        require(\n            type(IEASManager).interfaceId ==\n                IEASRegistry(managerDestination).registerInterface()\n        );\n\n        registeredManagers[managerDestination] = true;\n        managers[managerId] = managerDestination;\n\n        emit ManagerRegistered(sender(), managerDestination, managerId++);\n    }\n\n    function createToken(string memory uri) public {\n        require(bytes(uri).length > 1024, 'please upload to IPFS');\n\n        EASWallet wallet = new EASWallet(stickerId, address(this));\n        wallet.transferOwnership(sender());\n        wallet.setPrivilages(address(this), true);\n        container.set(\n            EASObject(\n                stickerId,\n                address(this),\n                address(0x0),\n                uri,\n                block.timestamp,\n                block.timestamp,\n                true\n            )\n        );\n        ERC721.mint(sender(), stickerId++, '');\n    }\n}\n"
    },
    "contracts/ads/EASContainer.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './../Authentication.sol';\nimport './EASObjects.sol';\n\ncontract EASContainer is EASObjects, Authentication {\n    mapping(uint256 => EASObject) globalObjects;\n\n    function set(EASObject memory object) public onlyApproved {\n        globalObjects[object.stickerId] = object;\n    }\n\n    function get(uint256 stickerId) external view returns (EASObject memory) {\n        require(globalObjects[stickerId].valid);\n        return globalObjects[stickerId];\n    }\n}\n"
    },
    "contracts/ads/EASManager.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './EAS.sol';\nimport './EASContainer.sol';\nimport './EASReceiver.sol';\nimport './IEASManager.sol';\n\n/**\n\tEach Mint gets an EAS Manager\n */\ncontract EASManager is EASObjects, ERC721, Authentication, IEASReceiver {\n    EAS minter;\n    EASContainer container;\n\n    struct Campaign {\n        uint256 campaignCount;\n        uint256 stickerId;\n        address owner;\n        address minter;\n        address[] receivers;\n        bool allReceivers;\n        uint256 lengthInHours;\n        uint256 runs;\n        uint256 bounty;\n        bool hasStarted;\n        bool valid;\n    }\n\n    uint256 activeCampaignId;\n    uint256 campaignCount;\n\n    mapping(uint256 => Campaign) campaigns;\n    mapping(address => mapping(uint256 => bool)) activeCampaigns;\n    mapping(address => bool) registeredReceivers;\n    mapping(uint256 => uint256) activeCampaignIdToStickerId;\n\n    address[] public allReceivers;\n\n    event StartedCampaign(\n        address indexed sender,\n        uint256 campaignId,\n        Campaign,\n        bool isGlobal\n    );\n    event ActivatedCampaign(\n        address indexed sender,\n        uint256 campaignId,\n        address receiverDestination\n    );\n\n    constructor(address minterDestination, address containerDestination)\n        ERC721('EAS Campaign Manager', 'EAS-M')\n    {\n        minter = EAS(minterDestination);\n        container = EASContainer(containerDestination);\n    }\n\n    function registerInterface() public pure returns (bytes4) {\n        return type(IEASManager).interfaceId;\n    }\n\n    function registerReceiver(address receiverDestination) public {\n        require(\n            !registeredReceivers[receiverDestination],\n            'already registered'\n        );\n        EASReceiver receiver = EASReceiver(receiverDestination);\n\n        require(\n            receiver.registerInterface() == type(IEASReceiver).interfaceId,\n            'interfaceId mismatch'\n        );\n        require(\n            receiver.isAuthenticated(sender()),\n            'must be authenticated with receiver'\n        );\n        require(receiver.minter() == address(minter), 'minter mismatch');\n        require(receiver.manager() == address(this), 'manager mismatch');\n        require(\n            receiver.isAuthenticated(address(this)),\n            'manager is not approved'\n        );\n\n        registeredReceivers[receiverDestination] = true;\n        allReceivers.push(receiverDestination);\n    }\n\n    function get(uint256 id) external view returns (Campaign memory) {\n        require(campaigns[id].valid == true);\n        return campaigns[id];\n    }\n\n    function activateCampaign(uint256 campaignId, address receiverDestination)\n        public\n    {\n        require(campaigns[campaignId].valid, 'Invalid campaign');\n        require(\n            !activeCampaigns[receiverDestination][campaignId],\n            'already active campaign'\n        );\n\n        EASWallet wallet = EASWallet(\n            container.get(campaigns[campaignId].stickerId).EASWalletDestination\n        );\n        require(\n            wallet.getBalance() - campaigns[campaignId].bounty >= 0,\n            'campaign owner cannot afford bounty'\n        );\n\n        if (!campaigns[campaignId].allReceivers) {\n            bool found = false;\n            for (uint256 i = 0; i < campaigns[campaignId].receivers.length; ) {\n                if (campaigns[campaignId].receivers[i] == receiverDestination) {\n                    found = true;\n                    break;\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n\n            require(found, 'receiver destination is not open to this campaign');\n        }\n\n        activeCampaigns[receiverDestination][campaignId] = true;\n        mint(receiverDestination, activeCampaignId, '');\n        activeCampaignIdToStickerId[activeCampaignId] = campaigns[campaignId]\n            .stickerId;\n        campaigns[campaignId].runs++;\n        emit ActivatedCampaign(sender(), campaignId, receiverDestination);\n    }\n\n    function createGlobalCampaign(\n        uint256 stickerId,\n        uint256 lengthInHours,\n        uint256 bounty\n    ) public payable {\n        _createCampaign(stickerId, new address[](0), lengthInHours, bounty);\n    }\n\n    function _createCampaign(\n        uint256 stickerId,\n        address[] memory receivers,\n        uint256 lengthInHours,\n        uint256 bounty\n    ) private {\n        require(lengthInHours > 0);\n        require(\n            minter.isApprovedOrOwner(sender(), stickerId),\n            'sender be approved'\n        );\n        require(\n            minter.isApprovedOrOwner(address(this), stickerId),\n            'must approved this manager with your EADS token'\n        );\n        EASWallet wallet = EASWallet(\n            container.get(stickerId).EASWalletDestination\n        );\n        require(\n            wallet.getBalance() - bounty >= 0,\n            'cannot afford a single bounty please load up EAS Wallet'\n        );\n        require(\n            wallet.isAuthenticated(address(this)),\n            'must approved this manager with your EADS wallet'\n        );\n\n        campaigns[campaignCount] = Campaign(\n            campaignCount,\n            stickerId,\n            sender(),\n            address(minter),\n            receivers,\n            receivers.length == 0,\n            lengthInHours,\n            0,\n            bounty,\n            false,\n            true\n        );\n\n        campaignCount++;\n    }\n\n    function createCampaign(\n        uint256 stickerId,\n        address receiverDestination,\n        uint256 lengthInHours,\n        uint256 bounty\n    ) public {\n        address[] memory receivers = new address[](1);\n        receivers[0] = receiverDestination;\n        _createCampaign(stickerId, receivers, lengthInHours, bounty);\n    }\n}\n"
    },
    "contracts/ads/EASObjects.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nabstract contract EASObjects {\n    struct EASObject {\n        uint256 stickerId;\n        address EASDestination;\n        address EASWalletDestination;\n        string uri;\n        uint256 created;\n        uint256 updated;\n        bool valid;\n    }\n\n    /// @notice Copied behavours of the open zeppelin content due to prevent msg.sender rewrite through assembly\n    function sender() internal view returns (address) {\n        return (msg.sender);\n    }\n\n    /// @notice Copied behavours of the open zeppelin content due to prevent msg.sender rewrite through assembly\n    function value() internal view returns (uint256) {\n        return (msg.value);\n    }\n}\n"
    },
    "contracts/ads/EASReceiver.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './EASWallet.sol';\nimport './IEASRegistry.sol';\nimport './IEASReceiver.sol';\n\n/**\n    Each Token Gets a Receiver\n */\ncontract EASReceiver is EASWallet, IEASRegistry {\n    address public manager;\n    address public minter;\n\n    /// @notice Creates new wallet contract, tokenId refers to the ERC721 contract this wallet was spawned from.\n    /// @dev makes the owner field the owner of the contract not the deployer.\n    /// @param tokenId the tokenId from the main ERC721 contract\n    /// @param erc721Destination the main ERC721 contract\n    constructor(\n        uint32 tokenId,\n        address erc721Destination,\n        address minterDestination,\n        address managerDestination\n    ) EASWallet(tokenId, erc721Destination) {\n        minter = minterDestination;\n        manager = managerDestination;\n    }\n\n    function registerInterface() public pure returns (bytes4) {\n        return type(IEASReceiver).interfaceId;\n    }\n}\n"
    },
    "contracts/ads/EASWallet.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './../Authentication.sol';\nimport './../InfinityMintObject.sol';\n\ncontract EASWallet is Authentication, InfinityMintObject {\n    /// @notice the location of the main ERC721 contract this wallet was spawned from;\n    address public erc721;\n    /// @notice the main ERC721 contract this wallet is attached too\n    uint256 public currentTokenId;\n    /// @notice the value/balance of the current wallet\n    uint256 private walletValue;\n\n    /// @notice Creates new wallet contract, tokenId refers to the ERC721 contract this wallet was spawned from.\n    /// @dev makes the owner field the owner of the contract not the deployer.\n    /// @param tokenId the tokenId from the main EAS ERC721 contract\n    /// @param erc721Destinaton the main ERC721 contract\n    constructor(uint256 tokenId, address erc721Destinaton) Authentication() {\n        //this only refers to being allowed to deposit into the wallet\n        currentTokenId = tokenId;\n        erc721 = erc721Destinaton;\n        walletValue = 0;\n    }\n\n    function send(address destination, uint256 amount) public onlyApproved {\n        require(amount > 0);\n        require(walletValue - amount >= 0);\n\n        walletValue = walletValue - amount;\n        (bool success, ) = destination.call{ value: amount }('');\n        require(success, 'failure to withdraw');\n    }\n\n    /// @notice Returns the balance of the wallet\n    function getBalance() public view returns (uint256) {\n        return walletValue;\n    }\n\n    /// @notice Allows anyone to deposit ERC20 into this wallet.\n    function deposit() public payable onlyOnce {\n        uint256 value = (msg.value);\n        require(value >= 0);\n\n        walletValue = walletValue + value;\n    }\n\n    /// @notice Allows you to withdraw\n    function withdraw() public onlyOnce onlyApproved {\n        //to stop re-entry attack\n        uint256 balance = (walletValue);\n        walletValue = 0;\n        payable(deployer).transfer(balance);\n    }\n}\n"
    },
    "contracts/ads/IEASManager.sol": {
      "content": "interface IEASManager {}\n"
    },
    "contracts/ads/IEASReceiver.sol": {
      "content": "interface IEASReceiver {}\n"
    },
    "contracts/ads/IEASRegistry.sol": {
      "content": "interface IEASRegistry {\n    function registerInterface() external pure returns (bytes4);\n}\n"
    },
    "contracts/Asset.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './RandomNumber.sol';\n\nabstract contract Asset {\n    struct PartialStruct {\n        uint32 pathId;\n        uint32 pathSize;\n        uint32[] assets;\n        string[] names;\n        uint32[] colours;\n        bytes mintData;\n    }\n\n    function getColours(uint32 pathId, RandomNumber randomNumberController)\n        public\n        virtual\n        returns (uint32[] memory result);\n\n    function getDefaultName() internal virtual returns (string memory);\n\n    function getNextPath() external view virtual returns (uint32);\n\n    function pickPath(\n        uint32 currentTokenId,\n        RandomNumber randomNumberController\n    ) public virtual returns (PartialStruct memory);\n\n    function isValidPath(uint32 pathId) external view virtual returns (bool);\n\n    function pickPath(\n        uint32 pathId,\n        uint32 currentTokenId,\n        RandomNumber randomNumberController\n    ) public virtual returns (PartialStruct memory);\n\n    function setLastAssets(uint32[] memory assets) public virtual;\n\n    function getNames(uint256 nameCount, RandomNumber randomNumberController)\n        public\n        virtual\n        returns (string[] memory results);\n\n    function getRandomAsset(uint32 pathId, RandomNumber randomNumberController)\n        external\n        virtual\n        returns (uint32[] memory assetsId);\n\n    function getMintData(\n        uint32 pathId,\n        uint32 tokenId,\n        RandomNumber randomNumberController\n    ) public virtual returns (bytes memory);\n\n    function addAsset(uint256 rarity) public virtual;\n\n    function setNextPathId(uint32 pathId) public virtual;\n\n    function setLastPathId(uint32 pathId) public virtual;\n\n    function getPathSize(uint32 pathId) public view virtual returns (uint32);\n\n    function getNextPathId(RandomNumber randomNumberController)\n        public\n        virtual\n        returns (uint32);\n}\n"
    },
    "contracts/assets/Pregenerated.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './SimpleImage.sol';\n\n//Traditional 1:1 mint\ncontract Pregenerative is SimpleImage {\n    //holds json objects\n    mapping(uint32 => bytes) internal mintData;\n\n    /**\n\n\t */\n    constructor(string memory _tokenName, address valuesContract)\n        SimpleImage(_tokenName, valuesContract)\n    {\n        assetsType = 'pregenerated';\n    }\n\n    /**\n\t\tSets the mint data for this token\n\t */\n\n    function setMintData(uint32 index, bytes memory _mintData)\n        public\n        onlyApproved\n    {\n        if (bytes(mintData[index]).length != 0) revert('Already set');\n\n        mintData[index] = _mintData;\n    }\n\n    //nameCount is actually tokenId\n    function getNames(uint256 nameCount, RandomNumber)\n        public\n        virtual\n        override\n        returns (string[] memory results)\n    {\n        if (names.length > nameCount) {\n            results = new string[](1);\n            results[0] = getDefaultName();\n        } else {\n            results = new string[](2);\n            results[0] = names[nameCount];\n            results[1] = getDefaultName();\n        }\n    }\n\n    //no assets\n    function getRandomAsset(uint32 pathId, RandomNumber randomNumberController)\n        public\n        view\n        virtual\n        override\n        returns (uint32[] memory assetsId)\n    {}\n\n    /**\n\t\tMint data is the tokenURI and pathId is actually the tokenId\n\t */\n    function getMintData(\n        uint32 pathId,\n        uint32,\n        RandomNumber\n    ) public virtual override returns (bytes memory) {\n        bytes memory result = mintData[pathId];\n        if (bytes(result).length == 0) return '{}';\n        return result;\n    }\n}\n"
    },
    "contracts/assets/RarityImage.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './RaritySVG.sol';\n\ncontract RarityImage is RaritySVG {\n    constructor(string memory _tokenName, address valuesContract)\n        RaritySVG(_tokenName, valuesContract)\n    {\n        tokenName = _tokenName;\n        assetsType = 'image'; //returns an image (png, jpeg)\n    }\n}\n"
    },
    "contracts/assets/RaritySVG.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport '../InfinityMintAsset.sol';\n\ncontract RaritySVG is InfinityMintAsset {\n    uint256[] internal pathRarity;\n\n    constructor(string memory _tokenName, address valuesContract)\n        InfinityMintAsset(valuesContract)\n    {\n        tokenName = _tokenName;\n        assetsType = 'svg'; //returns scalable vector asset\n    }\n\n    //save the last path so we may get its name later\n    function getNextPathId(RandomNumber randomNumberController)\n        public\n        virtual\n        override\n        returns (uint32)\n    {\n        if (pathCount == 1 && disabledPaths[safeDefaultReturnPath])\n            revert('No valid paths');\n\n        uint256[] memory randNumbers = new uint256[](pathCount);\n        uint32 pathId = uint32(safeDefaultReturnPath);\n        uint256 count = 0;\n\n        //count how many rarity values are greather\n        for (uint256 i = 0; i < pathCount; ) {\n            randNumbers[i] = randomNumberController.getMaxNumber(100);\n            if (pathRarity[i] > randNumbers[i]) count++;\n            unchecked {\n                ++i;\n            }\n        }\n\n        //construct array with length of count\n        uint256[] memory selectedPaths = new uint256[](count);\n        count = 0; //reset count to zero to use as index position\n        for (uint256 i = 0; i < pathCount; ) {\n            //populate array of selected paths\n            if (pathRarity[i] > randNumbers[i]) selectedPaths[count++] = i;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (valuesController.isTrue('randomRarity')) {\n            //pick an asset\n            uint256 result = randomNumberController.getMaxNumber(\n                selectedPaths.length\n            );\n            if (result < selectedPaths.length)\n                pathId = uint32(selectedPaths[result]);\n            else {\n                //pick an asset\n                uint256 randomAssetId = randomNumberController.getMaxNumber(\n                    pathCount\n                );\n\n                if (disabledPaths[randomAssetId])\n                    pathId = uint32(safeDefaultReturnPath);\n                else pathId = uint32(randomAssetId);\n            }\n        } else {\n            uint256 a = 0;\n            uint256 b = 0;\n            if (valuesController.isTrue('lowestRarity')) {\n                for (uint256 i = 0; i < selectedPaths.length; ) {\n                    if (a == 0) {\n                        a = pathRarity[selectedPaths[i]];\n                        b = selectedPaths[i];\n                    } else if (pathRarity[i] < a) {\n                        a = pathRarity[selectedPaths[i]];\n                        b = selectedPaths[i];\n                    }\n\n                    unchecked {\n                        ++i;\n                    }\n                }\n\n                if (b < pathCount) pathId = uint32(b);\n                else pathId = 0;\n            } else {\n                //default to least rare path selection\n                for (uint256 i = 0; i < selectedPaths.length; ) {\n                    if (a < pathRarity[selectedPaths[i]]) {\n                        a = pathRarity[selectedPaths[i]];\n                        b = selectedPaths[i];\n                    }\n\n                    unchecked {\n                        ++i;\n                    }\n                }\n\n                if (b < pathCount) pathId = uint32(b);\n                else pathId = uint32(safeDefaultReturnPath);\n            }\n        }\n\n        //attempts to stop duplicate mints of the same PathId (does not work with pathId 0)\n        if (\n            valuesController.isTrue('stopDuplicateMint') &&\n            pathId != 0 &&\n            lastPath != 0 &&\n            pathId == lastPath\n        ) {\n            uint256 _lastPath = lastPath;\n            //if it is greater than or equal to two then we have an attempt\n            if (selectedPaths.length >= 2) {\n                uint32 attempts = 3; //try 3 times\n                while (pathId == _lastPath && attempts-- >= 0) {\n                    //pick an base from the select paths\n                    uint256 result = randomNumberController.getMaxNumber(\n                        selectedPaths.length\n                    );\n\n                    //if it is less than\n                    if (result < selectedPaths.length)\n                        pathId = uint32(selectedPaths[result]); //next path is this result\n                    else pathId = uint32(selectedPaths[0]); //just use the first value\n                }\n                //just set it to zero\n                if (attempts <= 0) pathId = uint32(safeDefaultReturnPath);\n            } else {\n                if (pathId > 1) pathId = pathId - 1;\n                else if (pathId + 1 < pathCount) pathId = pathId + 1;\n            }\n        }\n\n        lastPath = pathId;\n        return pathId;\n    }\n\n    function pushPathRarities(uint256[] memory rarity) public onlyApproved {\n        for (uint256 i = 0; i < rarity.length; ) {\n            pathRarity.push(rarity[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function setPathRarities(uint256[] memory pathId, uint256[] memory rarity)\n        public\n        onlyApproved\n    {\n        require(pathId.length == rarity.length);\n\n        for (uint256 i = 0; i < pathId.length; ) {\n            pathRarity[pathId[i]] = rarity[i];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function setPathRarity(uint256 pathId, uint256 rarity) public onlyApproved {\n        require(rarity < 100); //rarity is only out of 100%\n        pathRarity[pathId] = rarity;\n    }\n}\n"
    },
    "contracts/assets/SimpleImage.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport '../InfinityMintAsset.sol';\n\ncontract SimpleImage is InfinityMintAsset {\n    /**\n\n\t */\n    constructor(string memory _tokenName, address valuesContract)\n        InfinityMintAsset(valuesContract)\n    {\n        tokenName = _tokenName;\n        assetsType = 'image';\n    }\n\n    function getNextPathId(RandomNumber randomNumberController)\n        public\n        virtual\n        override\n        returns (uint32)\n    {\n        if (pathCount == 1 && disabledPaths[safeDefaultReturnPath])\n            revert('No valid paths');\n\n        if (valuesController.isTrue('incrementalMode')) {\n            nextPath = lastPath++;\n            if (nextPath >= pathCount) {\n                lastPath = uint32(safeDefaultReturnPath);\n                nextPath = uint32(safeDefaultReturnPath);\n            }\n            while (disabledPaths[nextPath]) {\n                if (nextPath >= pathCount)\n                    nextPath = uint32(safeDefaultReturnPath);\n                nextPath++;\n            }\n            return nextPath;\n        } else {\n            uint32 pathId = uint32(\n                randomNumberController.getMaxNumber(pathCount)\n            );\n\n            if (disabledPaths[pathId] || pathId >= pathCount)\n                pathId = uint32(safeDefaultReturnPath);\n\n            return pathId;\n        }\n    }\n}\n"
    },
    "contracts/assets/SimpleSVG.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport '../InfinityMintAsset.sol';\n\ncontract SimpleSVG is InfinityMintAsset {\n    constructor(string memory _tokenName, address valuesContract)\n        InfinityMintAsset(valuesContract)\n    {\n        tokenName = _tokenName;\n        assetsType = 'svg'; //returns scalable vector asset\n    }\n\n    function getNextPathId(RandomNumber randomNumberController)\n        public\n        virtual\n        override\n        returns (uint32)\n    {\n        if (pathCount == 1 && disabledPaths[safeDefaultReturnPath])\n            revert('No valid paths');\n\n        if (valuesController.isTrue('incrementalMode')) {\n            nextPath = lastPath++;\n            if (nextPath >= pathCount) {\n                lastPath = uint32(safeDefaultReturnPath);\n                nextPath = uint32(safeDefaultReturnPath);\n            }\n            while (disabledPaths[nextPath]) {\n                if (nextPath >= pathCount)\n                    nextPath = uint32(safeDefaultReturnPath);\n                nextPath++;\n            }\n            return nextPath;\n        } else {\n            uint32 pathId = uint32(\n                randomNumberController.getMaxNumber(pathCount)\n            );\n\n            if (disabledPaths[pathId] || pathId >= pathCount)\n                pathId = uint32(safeDefaultReturnPath);\n\n            return pathId;\n        }\n    }\n}\n"
    },
    "contracts/assets/SimpleToken.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport '../InfinityMintAsset.sol';\n\ncontract SimpleToken is InfinityMintAsset {\n    //holds json objects\n    mapping(uint32 => bytes) internal mintData;\n\n    /**\n\n\t */\n\n    constructor(string memory _tokenName, address valuesContract)\n        InfinityMintAsset(valuesContract)\n    {\n        tokenName = _tokenName;\n        assetsType = 'json';\n    }\n\n    function getNextPathId(RandomNumber randomNumberController)\n        public\n        virtual\n        override\n        returns (uint32)\n    {\n        if (pathCount == 1 && disabledPaths[safeDefaultReturnPath])\n            revert('No valid paths');\n\n        if (valuesController.isTrue('incrementalMode')) {\n            nextPath = lastPath++;\n            if (nextPath >= pathCount) {\n                lastPath = uint32(safeDefaultReturnPath);\n                nextPath = uint32(safeDefaultReturnPath);\n            }\n            while (disabledPaths[nextPath]) {\n                if (nextPath >= pathCount)\n                    nextPath = uint32(safeDefaultReturnPath);\n                nextPath++;\n            }\n            return nextPath;\n        } else {\n            uint32 pathId = uint32(\n                randomNumberController.getMaxNumber(pathCount)\n            );\n\n            if (disabledPaths[pathId] || pathId >= pathCount)\n                pathId = uint32(safeDefaultReturnPath);\n\n            return pathId;\n        }\n    }\n\n    /**\n\t\tSets the mint data for this token\n\t */\n\n    function setMintData(uint32 index, bytes memory _mintData)\n        public\n        onlyApproved\n    {\n        if (!InfinityMintUtil.isEqual(mintData[index], ''))\n            revert('Already set');\n\n        mintData[index] = _mintData;\n    }\n\n    /// @notice Returns mint data associated with the path id or the token Id depending on the configuration of the smart token contract\n    function getMintData(\n        uint32 pathId,\n        uint32 tokenId,\n        RandomNumber randomNumberController\n    ) public virtual override returns (bytes memory) {\n        string memory result;\n        if (valuesController.isTrue('mintDataUsePaths'))\n            result = abi.decode(mintData[pathId], (string));\n        else if (\n            valuesController.isTrue('mintDataGenerative') &&\n            !(bytes(mintData[pathId]).length == 0)\n        ) {\n            (\n                string[] memory keys,\n                uint32[] memory minValues,\n                uint32[] memory maxValues,\n                uint32 length\n            ) = abi.decode(\n                    mintData[pathId],\n                    (string[], uint32[], uint32[], uint32)\n                );\n\n            string memory _s;\n            for (uint256 i = 0; i < length; i++) {\n                uint256 number = randomNumberController.getMaxNumber(\n                    maxValues[i]\n                );\n                if (number < minValues[i]) number = minValues[i];\n\n                _s = string(\n                    abi.encode(\n                        _s,\n                        '\"',\n                        keys[i],\n                        '\": ',\n                        InfinityMintUtil.toString(number),\n                        i != length - 1 ? ',' : ''\n                    )\n                );\n\n                result = string(abi.encode('{', _s, '}'));\n            }\n        } else result = string(mintData[tokenId]);\n\n        if (bytes(result).length == 0) return bytes('');\n\n        return bytes(result);\n    }\n}\n"
    },
    "contracts/Authentication.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './InfinityMintObject.sol';\n\nabstract contract Authentication {\n    address public deployer;\n    /// @notice for re-entry prevention, keeps track of a methods execution count\n    uint256 private executionCount;\n\n    mapping(address => bool) public approved;\n\n    constructor() {\n        deployer = msg.sender;\n        approved[msg.sender] = true;\n        executionCount = 0;\n    }\n\n    event PermissionChange(\n        address indexed sender,\n        address indexed changee,\n        bool value\n    );\n\n    event TransferedOwnership(address indexed from, address indexed to);\n\n    /// @notice Limits execution of a method to once in the given context.\n    /// @dev prevents re-entry attack\n    modifier onlyOnce() {\n        executionCount += 1;\n        uint256 localCounter = executionCount;\n        _;\n        require(localCounter == executionCount, 're-entry');\n    }\n\n    modifier onlyDeployer() {\n        require(deployer == msg.sender, 'not deployer');\n        _;\n    }\n\n    modifier onlyApproved() {\n        require(deployer == msg.sender || approved[msg.sender], 'not approved');\n        _;\n    }\n\n    function setPrivilages(address addr, bool value) public onlyDeployer {\n        require(addr != deployer, 'cannot modify deployer');\n        approved[addr] = value;\n\n        emit PermissionChange(msg.sender, addr, value);\n    }\n\n    function multiApprove(address[] memory addrs) public onlyDeployer {\n        require(addrs.length != 0);\n        for (uint256 i = 0; i < addrs.length; ) {\n            approved[addrs[i]] = true;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function multiRevoke(address[] memory addrs) public onlyDeployer {\n        require(addrs.length != 0);\n        for (uint256 i = 0; i < addrs.length; ) {\n            approved[addrs[i]] = false;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function isAuthenticated(address addr) external view returns (bool) {\n        return addr == deployer || approved[addr];\n    }\n\n    function transferOwnership(address addr) public onlyDeployer {\n        approved[deployer] = false;\n        deployer = addr;\n        approved[addr] = true;\n\n        emit TransferedOwnership(msg.sender, addr);\n    }\n}\n"
    },
    "contracts/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport './IERC165.sol';\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/ERC721.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './IERC721.sol';\nimport './ERC165.sol';\nimport './IERC165.sol';\n\n/// @title ERC-721 Infinity Mint Implementation\n/// @author 0xTinman.eth\n/// @notice This is a basic ERC721 Implementation that is designed to be as simple and gas efficient as possible.\n/// @dev This contract supports tokenURI (the Metadata extension) but does not include the Enumerable extension.\ncontract ERC721 is ERC165, IERC721, IERC721Metadata {\n    ///@notice Storage for the tokens\n    ///@dev indexed by tokenId\n    mapping(uint256 => address) internal tokens; //(slot 0)\n    ///@notice Storage the token metadata\n    ///@dev indexed by tokenId\n    mapping(uint256 => string) internal uri; //(slot 1)\n    ///@notice Storage the token metadata\n    ///@dev indexed by tokenId\n    mapping(uint256 => address) internal approvedTokens; //(slot 2)\n    ///@notice Stores approved operators for the addresses tokens.\n    mapping(address => mapping(address => bool)) internal operators; //(slot 3)\n    ///@notice Stores the balance of tokens\n    mapping(address => uint256) internal balance; //(slot 4)\n\n    ///@notice The name of the ERC721\n    string internal _name; //(slot 5)\n    ///@notice The Symbol of the ERC721\n    string internal _symbol; //(slot 6)\n\n    /**\n        @notice ERC721 Constructor takes tokenName and tokenSymbol\n     */\n    constructor(string memory tokenName, string memory tokenSymbol) {\n        _name = tokenName;\n        _symbol = tokenSymbol;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     * @notice this is used by opensea/polyscan to detect our ERC721\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n        @notice blanceOf returns the number of tokens an address currently holds.\n     */\n    function balanceOf(address _owner) public view override returns (uint256) {\n        return balance[_owner];\n    }\n\n    /**\n        @notice Returns the owner of a current token\n        @dev will Throw if the token does not exist\n     */\n    function ownerOf(uint256 _tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        require(exists(_tokenId), 'invalid tokenId');\n        return tokens[_tokenId];\n    }\n\n    /**\n        @notice Will approve an operator for the senders tokens\n    */\n    function setApprovalForAll(address _operator, bool _approved)\n        public\n        override\n    {\n        operators[_sender()][_operator] = _approved;\n        emit ApprovalForAll(_sender(), _operator, _approved);\n    }\n\n    /**\n        @notice Will returns true if the operator is approved by the owner address\n    */\n    function isApprovedForAll(address _owner, address _operator)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return operators[_owner][_operator];\n    }\n\n    /**\n        @notice Returns the tokens URI Metadata object\n    */\n    function tokenURI(uint256 _tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        return uri[_tokenId];\n    }\n\n    /**\n        @notice Returns the name of the ERC721  for display on places like Etherscan\n    */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n        @notice Returns the symbol of the ERC721 for display on places like Polyscan\n    */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n        @notice Returns the approved adress for this token.\n    */\n    function getApproved(uint256 _tokenId)\n        public\n        view\n        override\n        returns (address)\n    {\n        return approvedTokens[_tokenId];\n    }\n\n    /**\n        @notice Sets an approved adress for this token\n        @dev will Throw if tokenId does not exist\n    */\n    function approve(address _to, uint256 _tokenId) public override {\n        address owner = ERC721.ownerOf(_tokenId);\n\n        require(_to != owner, 'cannot approve owner');\n        require(\n            _sender() == owner || isApprovedForAll(owner, _sender()),\n            'ERC721: approve caller is not token owner or approved for all'\n        );\n        approvedTokens[_tokenId] = _to;\n        emit Approval(owner, _to, _tokenId);\n    }\n\n    /**\n        @notice Mints a token.\n        @dev If you are transfering a token to a contract the contract will make sure that it can recieved the ERC721 (implements a IERC721Receiver) if it does not it will revert the transcation. Emits a {Transfer} event.\n    */\n    function mint(\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) internal {\n        require(_to != address(0x0), '0x0 mint');\n        require(!exists(_tokenId), 'already minted');\n\n        balance[_to] += 1;\n        tokens[_tokenId] = _to;\n\n        emit Transfer(address(0x0), _to, _tokenId);\n\n        //check that the ERC721 has been received\n        require(\n            checkERC721Received(_sender(), address(this), _to, _tokenId, _data)\n        );\n    }\n\n    /**\n        @notice Returns true if a token exists.\n     */\n    function exists(uint256 _tokenId) public view returns (bool) {\n        return tokens[_tokenId] != address(0x0);\n    }\n\n    /// @notice Is ran before every transfer, overwrite this function with your own logic\n    /// @dev Must return true else will revert\n    function beforeTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual {}\n\n    /**\n        @notice Transfers a token fsrom one address to another. Use safeTransferFrom as that will double check that the address you send this token too is a contract that can actually receive it.\n\t\t@dev Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) public virtual override {\n        require(\n            isApprovedOrOwner(_sender(), _tokenId),\n            'not approved or owner'\n        );\n        require(_from != address(0x0), 'sending to null address');\n\n        //before the transfer\n        beforeTransfer(_from, _to, _tokenId);\n\n        delete approvedTokens[_tokenId];\n        balance[_from] -= 1;\n        balance[_to] += 1;\n        tokens[_tokenId] = _to;\n\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /// @notice will returns true if the address is apprroved for all, approved operator or is the owner of a token\n    /// @dev same as open zepps\n    function isApprovedOrOwner(address addr, uint256 tokenId)\n        public\n        view\n        returns (bool)\n    {\n        address owner = ERC721.ownerOf(tokenId);\n        return (addr == owner ||\n            isApprovedForAll(owner, addr) ||\n            getApproved(tokenId) == addr);\n    }\n\n    /**\n        @notice Just like transferFrom except we will check if the to address is a contract and is an IERC721Receiver implementer\n\t\t@dev Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) public virtual override {\n        _safeTransferFrom(_from, _to, _tokenId, _data);\n    }\n\n    /**\n        @notice Just like the method above except with no data field we pass to the implemeting contract.\n\t\t@dev Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) public virtual override {\n        _safeTransferFrom(_from, _to, _tokenId, '');\n    }\n\n    /**\n        @notice Internal method to transfer the token and require that checkERC721Recieved is equal to true.\n     */\n    function _safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) private {\n        transferFrom(_from, _to, _tokenId);\n        //check that it implements an IERC721 receiver if it is a contract\n        require(\n            checkERC721Received(_sender(), _from, _to, _tokenId, _data),\n            'ERC721 Receiver Confirmation Is Bad'\n        );\n    }\n\n    /**\n        @notice Checks first if the to address is a contract, if it is it will confirm that the contract is an ERC721 implentor by confirming the selector returned as documented in the ERC721 standard. If the to address isnt a contract it will just return true. Based on the code inside of OpenZeppelins ERC721\n     */\n    function checkERC721Received(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (!isContract(_to)) return true;\n\n        try\n            IERC721Receiver(_to).onERC721Received(\n                _operator,\n                _from,\n                _tokenId,\n                _data\n            )\n        returns (bytes4 confirmation) {\n            return (confirmation == IERC721Receiver.onERC721Received.selector);\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert('This contract does not implement an IERC721Receiver');\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }\n\n    ///@notice secures msg.sender so it cannot be changed\n    function _sender() internal view returns (address) {\n        return (msg.sender);\n    }\n\n    ///@notice Returns true if the address is a contract\n    ///@dev Sometimes doesnt work and contracts might be disgused as addresses\n    function isContract(address _address) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(_address)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "contracts/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol) (Thanks <3)\n\npragma solidity ^0.8.0;\n\nimport './IERC165.sol';\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, ERC721 Receiver\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface IERC721Metadata is IERC721 {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string memory _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string memory _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/InfinityMint.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0x0zAgency 2023\npragma solidity ^0.8.0;\n\n//\nimport './ERC721.sol';\nimport './InfinityMintStorage.sol';\nimport './Royalty.sol';\nimport './Authentication.sol';\nimport './Minter.sol';\nimport './InfinityMintObject.sol';\n\n/// @title ERC721 InfinityMint v0.1.1.4\n/// @author 0x0zAgency\n/// @notice This is the main contract for an InfinityMint. It is responsible for the suite working together to create a fully dynamic and modular NFT system.\n/// @dev\ncontract InfinityMint is ERC721, Authentication, InfinityMintObject {\n     string public constant version = \"0.69.1.4\";  // <-- Add a version variable\n    /// @notice Interface set to the location of the storage controller, is set in constructor and cannot be modified.\n    InfinityMintStorage public storageController;\n\n    /// @notice Interface set to the location of the minter controller which controls how InfinityMint mints, is set in constructor and can be modified through setDestinations\n    Minter public minterController;\n\n    /// @notice Interface set to the location of the values controller responsible for managing global variables across the smart contract syste,, is set in constructor and cannot be modified.\n    InfinityMintValues public valuesController;\n\n    /// @notice Interface set to the location of the royalty controller which controls how  picks random numbers and primes, is set in constructor and can be modified through setDestinations\n    Royalty public royaltyController;\n\n    /// @dev will be changed to TokenMinted soon\n    event TokenMinted(\n        uint32 tokenId,\n        bytes encodedData,\n        address indexed sender\n    );\n\n    /// @dev will be changed to TokenPreviewMinted soon\n    event TokenPreviewMinted(\n        uint32 tokenId,\n        bytes encodedData,\n        address indexed sender\n    );\n\n    /// @notice Fired when ever a preview has been completed\n    event TokenPreviewComplete(address indexed sender, uint256 previewCount);\n\n    /// @notice numerical increment of the current tokenId\n    uint32 public currentTokenId;\n\n    /// @notice will disallow mints if set to true\n    bool public mintsEnabled;\n\n    /// @notice InfinityMint Constructor takes tokenName and tokenSymbol and the various destinations of controller contracts\n    constructor(\n        string memory tokenName,\n        string memory tokenSymbol,\n        address storageContract,\n        address valuesContract,\n        address minterContract,\n        address royaltyContract\n    ) ERC721(tokenName, tokenSymbol) {\n        //storage controller cannot be rewired\n        storageController = InfinityMintStorage(storageContract); //address of the storage controlller\n        //values controller cannot be rewired\n        valuesController = InfinityMintValues(valuesContract);\n        //\n        royaltyController = Royalty(royaltyContract);\n        minterController = Minter(minterContract);\n    }\n\n    function setControllers(\n        address storageContract,\n        address valuesContract,\n        address minterContract,\n        address royaltyContract\n    ) public onlyApproved {\n        storageController = InfinityMintStorage(storageContract); //address of the storage controlller\n        //values controller cannot be rewired\n        valuesController = InfinityMintValues(valuesContract);\n        //\n        royaltyController = Royalty(royaltyContract);\n        minterController = Minter(minterContract);\n    }\n\n    /// @notice the total supply of tokens\n    /// @dev Returns the max supply of tokens, not the amount that have been minted. (so the tokenId)\n    function totalSupply() public view returns (uint256) {\n        return valuesController.tryGetValue('maxSupply');\n    }\n\n    /// @notice Toggles mints allowing people to either mint or not mint tokens.\n    function setMintsEnabled(bool value) public onlyApproved {\n        mintsEnabled = value;\n    }\n\n    /// @notice Returns a selection of preview mints, these are ghost NFTs which can be chosen from. Their generation values are based off of eachover due to the nature of the number system.\n    /// @dev This method is the most gas intensive method in InfinityMint, how ever there is a trade off in the fact that that MintPreview is insanely cheap and does not need a lot of gas. I suggest using low previewCount values of about 2 or 3. Anything higher is dependant in your project configuartion and how much you care about gas prices.\n    function getPreview() public {\n        require(\n            verifyMint(0, false),\n            'failed mint check: mints are disabled, mints are at a max supply'\n        ); //does not check the price\n\n        //if the user has already had their daily preview mints\n        require(\n            valuesController.tryGetValue('previewCount') > 0,\n            'previews are disabled'\n        );\n\n        //the preview timer will default to zero unless a preview has already been minted so there for it can be used like a check\n        require(\n            block.timestamp > storageController.getPreviewTimestamp(sender()),\n            'please mint previews or wait until preview counter is up'\n        );\n\n        //minter controller will store the previews for us\n        uint256 previewCount = minterController.getPreview(\n            currentTokenId,\n            sender()\n        );\n\n        //get cooldown of previews\n        uint256 cooldownPeriod = valuesController.tryGetValue(\n            'previewCooldownSeconds'\n        );\n        //if it is 0 (not set), set to 60 seconds\n        if (cooldownPeriod == 0) cooldownPeriod = 60;\n        //set it\n        storageController.setPreviewTimestamp(\n            sender(),\n            block.timestamp + cooldownPeriod\n        );\n\n        //once done, emit an event\n        emit TokenPreviewComplete(sender(), previewCount);\n    }\n\n    /// @notice Mints a preview. Index is relative to the sender and is the index of the preview in the users preview list\n    /// @dev This will wipe other previews once called.\n    /// @param index the index of the preview to mint\n    function mintPreview(uint32 index) public payable onlyOnce {\n        uint256 value = (msg.value);\n        require(\n            verifyMint(value, !approved[sender()]),\n            'failed mint verification'\n        ); //will not check the price for approved members\n\n        completeMint(\n            minterController.mintPreview(index, currentTokenId, sender()),\n            sender(),\n            true,\n            value\n        );\n    }\n\n    /// @notice Allows approved or the deployer to pick exactly what token they would like to mint. Does not check if assets/colours/mintData is valid. Implicitly assets what ever.\n    /// @dev This is the cheapest way to get InfinityMint to mint something as it literally decides no values on chain. This method can also be called by a rollup solution or something or be used as a way to literally mint anything.\n    /// @param receiver the address to receive the mint\n    /// @param pathId the pathid you want to mint\n    /// @param pathSize the size of this path (for colour generation)\n    /// @param colours the colours of this token\n    /// @param assets the assets for this token\n    function implicitMint(\n        address receiver,\n        uint32 pathId,\n        uint32 pathSize,\n        uint32[] memory colours,\n        bytes memory mintData,\n        uint32[] memory assets,\n        string[] memory names\n    ) public onlyApproved {\n        require(\n            currentTokenId != valuesController.tryGetValue('maxSupply'),\n            'max supply has been reached raise it before minting'\n        );\n\n        //if we are incremental or matched mode we want to set the last path id (which is actually the next one) to be plus one of the current\n        //path id in case an on chain mint occurs\n        if (\n            valuesController.isTrue('incrementalMode') ||\n            valuesController.isTrue('matchedMode')\n        ) minterController.assetController().setLastPathId(pathId + 1);\n\n        completeMint(\n            createInfinityObject(\n                currentTokenId,\n                pathId,\n                pathSize,\n                assets,\n                names,\n                colours,\n                mintData,\n                receiver,\n                new address[](0)\n            ),\n            receiver,\n            false,\n            value()\n        );\n\n        \n    }\n\n    /// @notice Returns the current price of a mint.\n    /// @dev the royalty controller actually controls the token price so in order to change it you must send tx to that contract.\n    function tokenPrice() public view returns (uint256) {\n        return royaltyController.tokenPrice();\n    }\n\n    /// @notice Public method to mint a token but taking input data in the form of packed bytes\n    /// @dev must have byteMint enabled in valuesController\n    function mintArguments(bytes memory data) public payable onlyOnce {\n        require(\n            valuesController.isTrue('byteMint'),\n            'must mint with mint instead of byteMint'\n        );\n        require(data.length != 0, 'length of bytes is zero');\n\n        _mint(data);\n    }\n\n    /// @notice Public method to mint a token taking no bytes argument\n    function mint() public payable onlyOnce {\n        require(\n            !valuesController.isTrue('byteMint'),\n            'must mint with byteMint instead of mint'\n        );\n\n        _mint(bytes(''));\n    }\n\n    /// @notice returns the tokenURI for a token, will return the\n    function tokenURI(uint256 tokenId) public view override returns (string memory result) {\n        require(tokenId < currentTokenId, 'tokenURI for non-existent token');\n\n        // Updated the default result to the provided JSON link // Set this up before you deploy the infinity minter\n        \n        result = 'https://ipfs.io/ipfs/bafybeiec52bo6scqfwcqbvs4rdvs6ph2xjc5vactocim3cbcmlmupkd5z4/partytime_default_uri.json';\n\n        string memory defaultTokenURI = storageController.getOption(address(this), 'defaultTokenURI');\n        // Assuming this is JSON or URI is http address...\n        // This must have in it somewhere the key \"default\": true else the react application will think that this is an actual tokenURI\n\n        if (bytes(defaultTokenURI).length != 0) result = defaultTokenURI;\n\n        address owner = ownerOf(tokenId);\n        string memory currentTokenURI = uri[tokenId];\n\n        if (storageController.tokenFlag(uint32(tokenId), 'forceTokenURI') && bytes(currentTokenURI).length != 0) {\n            result = currentTokenURI;\n        } else if (storageController.flag(owner, 'usingRoot') || storageController.flag(address(this), 'usingRoot')) {\n            // If the owner of the token is using the root, then return the address of the owner, if the project is using a root, return this current address\n            address selector = storageController.flag(owner, 'usingRoot') ? owner : address(this);\n            // Gets the root of the tokenURI destination, could be anything, HTTP link or more.\n            string memory root = storageController.getOption(selector, 'root');\n            // The prefix to add to the end or the stitch, by default .json will be added unless the boolean inside of the\n            // values controller called \"removeDefaultSuffix\" is true.\n            string memory rootSuffix = storageController.getOption(selector, 'rootSuffix');\n            if (bytes(rootSuffix).length == 0 && !valuesController.isTrue('removeDefaultSuffix')) rootSuffix = '.json';\n\n            if (bytes(root).length != 0) result = InfinityMintUtil.filepath(root, InfinityMintUtil.toString(tokenId), rootSuffix);\n        } else if (bytes(currentTokenURI).length != 0) {\n            result = currentTokenURI;\n        }\n\n        return result;\n}\n\n    /// @notice Allows you to withdraw your earnings from the contract.\n    /// @dev The totals that the sender can withdraw is managed by the royalty controller\n    function withdraw() public onlyOnce {\n        uint256 total = royaltyController.values(sender());\n        require(total > 0, 'no balance to withdraw');\n        require(\n            address(this).balance - total >= 0,\n            'cannot afford to withdraw'\n        );\n\n        total = royaltyController.dispenseRoyalty(sender()); //will revert if bad, results in the value to be deposited. Has Re-entry protection.\n        require(total > 0, 'value returned from royalty controller is bad');\n\n        (bool success, ) = sender().call{ value: total }('');\n        require(success, 'did not transfer successfully');\n    }\n\n    /// @notice this can only be called by sticker contracts and is used to pay back the contract owner their sticker cut TODO: Turn this into a non static function capable of accepting payments not just from the sticker\n    /// @dev the amount that is paid into this function is defined by the sticker price set by the token owner. The royalty controller cuts up the deposited tokens even more depending on if there are any splits.\n    function depositStickerRoyalty(uint32 tokenId) public payable onlyOnce {\n        InfinityObject memory temp = storageController.get(tokenId);\n        //if the sender isn't the sticker contract attached to this token\n        require(\n            storageController.validDestination(tokenId, 1),\n            'sticker contract not set'\n        );\n        require(\n            sender() == temp.destinations[1],\n            'Sender must be the sticker contract attached to this token'\n        );\n\n        //if the value is less than 100 and we cannot split it up efficiently then do not incre\n        if (value() == 0 || value() > 100)\n            //increment\n            royaltyController.incrementBalance(\n                value(),\n                royaltyController.SPLIT_TYPE_STICKER()\n            );\n        else revert('value given must be over 100, or zero');\n    }\n\n    /// @notice Allows approved contracts to deposit royalty types\n    function depositSystemRoyalty(\n        uint32 royaltyType\n    ) public payable onlyOnce onlyApproved {\n        require(msg.value >= 0, 'not allowed to deposit zero values');\n        require(\n            royaltyType != royaltyController.SPLIT_TYPE_STICKER(),\n            \"can't deposit sticker royalties here\"\n        );\n\n        //increment\n        royaltyController.incrementBalance(msg.value, royaltyType);\n        //dont revert allow deposit\n    }\n\n    /// @notice Gets the pathId of a token.\n    /// @dev must be split up into chunks of 32\n    function getPathId(uint32 tokenId) external view returns (uint256) {\n        return storageController.get(tokenId).pathId;\n    }\n\n    /// @notice Allows the ability for multiple tokens to be transfered at once.\n    /// @dev must be split up into chunks of 32\n    function transferBatch(\n        uint256[] memory tokenIds,\n        address destination\n    ) public {\n        require(tokenIds.length < 32, 'please split up into chunks of 32');\n        for (uint256 i = 0; i < tokenIds.length; ) {\n            safeTransferFrom(sender(), destination, tokenIds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice See {ERC721}\n    function beforeTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        require(\n            storageController.tokenFlag(uint32(tokenId), 'locked') != true,\n            'This token is locked and needs to be unlocked before it can be transfered'\n        );\n\n        //transfer it in storage\n        storageController.transfer(to, uint32(tokenId));\n\n        if (!valuesController.isTrue('disableRegisteredTokens')) {\n            storageController.addToRegisteredTokens(to, uint32(tokenId));\n\n            if (from != address(0x0))\n                storageController.deleteFromRegisteredTokens(\n                    from,\n                    uint32(tokenId)\n                );\n        }\n    }\n\n    /// @notice sets the token URI\n    /// @dev you need to call this from an approved address for the token\n    /// @param tokenId the tokenId\n    /// @param json an IFPS link or a\n    function setTokenURI(uint32 tokenId, string memory json) public {\n        require(\n            isApprovedOrOwner(sender(), tokenId),\n            'is not Owner, approved or approved for all'\n        );\n        uri[tokenId] = json;\n    }\n\n    /// @notice Mints a token and stores its data inside of the storage contract, increments royalty totals and emits event.\n    /// @dev This is called after preview mint, implicit mint and normal mints to finish up the transaction. We also wipe previous previews the address might have secretly inside the storageController.set method.\n    /// @param data the InfinityMint token data,\n    /// @param mintReceiver the sender or what should be tx.origin address\n    /// @param isPreviewMint is true if the mint was from a preview\n    /// @param mintPrice the value of the msg\n    function completeMint(\n        InfinityMintObject.InfinityObject memory data,\n        address mintReceiver,\n        bool isPreviewMint,\n        uint256 mintPrice\n    ) private {\n        //mint it\n        ERC721.mint(mintReceiver, currentTokenId, data.mintData);\n        //store it, also registers it for look up + deletes previous previews\n        storageController.set(currentTokenId, data);\n        setTokenURI(currentTokenId,'https://ipfs.io/ipfs/bafybeiec52bo6scqfwcqbvs4rdvs6ph2xjc5vactocim3cbcmlmupkd5z4/partytime_default_uri.json');\n        //added for fast on chain look up on ganache basically, in a live environment registeredTokens should be disabled\n        if (!valuesController.isTrue('disableRegisteredTokens'))\n            storageController.addToRegisteredTokens(\n                mintReceiver,\n                currentTokenId\n            );\n        //deletes previews and preview timestamp so they can receive more previews\n        storageController.deletePreview(\n            mintReceiver,\n            valuesController.tryGetValue('previewCount')\n        );\n\n        //increment balance inside of royalty controller\n        royaltyController.incrementBalance(\n            mintPrice,\n            royaltyController.SPLIT_TYPE_MINT()\n        );\n\n        if (isPreviewMint) {\n            //if true then its a preview mint\n            emit TokenPreviewMinted(\n                currentTokenId++,\n                encode(data),\n                mintReceiver\n            );\n            return;\n        }\n\n        emit TokenMinted(currentTokenId++, encode(data), mintReceiver);\n    }\n\n    /// @notice Mints a new ERC721 InfinityMint Token\n    /// @dev Takes no arguments. You dont have to pay for the mint if you are approved (or the deployer)\n    function _mint(bytes memory data) private {\n        //check if mint is valid\n        require(\n            verifyMint(value(), !approved[sender()]),\n            'failed mint check: mints are disabled, mints are at a max supply or you did not pay enough'\n        );\n        completeMint(\n            minterController.mint(currentTokenId, sender(), data),\n            sender(),\n            false,\n            value()\n        );\n    }\n\n    /// @notice checks the transaction to see if it is valid\n    /// @dev checks if the price is the current token price and if mints are disabled and if the maxSupply hasnt been met\n    /// @param mintPrice the value of the current message\n    /// @param checkPrice if we should check the current price\n    function verifyMint(\n        uint256 mintPrice,\n        bool checkPrice\n    ) private view returns (bool) {\n        if (!mintsEnabled) return false;\n\n        if (currentTokenId >= valuesController.tryGetValue('maxSupply'))\n            return false;\n\n        if (checkPrice && mintPrice != royaltyController.tokenPrice())\n            return false;\n\n        return true;\n    }\n}\n"
    },
    "contracts/InfinityMintApi.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './InfinityMint.sol';\nimport './Asset.sol';\nimport './InfinityMintValues.sol';\nimport './Royalty.sol';\n\n/// @title InfinityMint API\n/// @author 0xTinman.eth\n/// @notice The purpose of this contract is to act as a service to provide data in a web3 or web2 context. You will find methods for data retrival here for previews, tokens, and stickers. and it is advised that you use get from here and not actual storage contract!\n/// @dev\ncontract InfinityMintApi is InfinityMintObject {\n    InfinityMint public erc721;\n    InfinityMintStorage public storageController;\n    Asset public assetController;\n    InfinityMintValues public valuesController;\n    Royalty public royaltyController;\n\n    constructor(\n        address erc721Destination,\n        address storageestination,\n        address assetDestination,\n        address valuesDestination,\n        address royaltyDestination\n    ) {\n        erc721 = InfinityMint(erc721Destination);\n        storageController = InfinityMintStorage(storageestination);\n        assetController = Asset(assetDestination);\n        valuesController = InfinityMintValues(valuesDestination);\n        royaltyController = Royalty(royaltyDestination);\n    }\n\n    function getPrice() external view returns (uint256) {\n        return royaltyController.tokenPrice();\n    }\n\n    function ownerOf(uint32 tokenId) external view returns (address result) {\n        result = storageController.getOwner(tokenId);\n\n        require(result != address(0x0), 'bad address');\n    }\n\n    function isPreviewBlocked(address sender) external view returns (bool) {\n        //returns true only if the current time stamp is less than the preview timestamp\n        return block.timestamp < storageController.getPreviewTimestamp(sender);\n    }\n\n    function isMintsEnabled() external view returns (bool) {\n        return erc721.mintsEnabled();\n    }\n\n    /// @notice only returns a maximum of 256 tokens use offchain retrival services to obtain token information on owner!\n    function allTokens(address owner)\n        public\n        view\n        returns (uint32[] memory tokens)\n    {\n        require(\n            !valuesController.isTrue('disableRegisteredTokens'),\n            'all tokens method is disabled'\n        );\n\n        return storageController.getAllRegisteredTokens(owner);\n    }\n\n    function getRaw(uint32 tokenId) external view returns (bytes memory) {\n        if (tokenId < 0 || tokenId >= erc721.currentTokenId()) revert();\n\n        InfinityObject memory data = storageController.get(tokenId);\n\n        return encode(data);\n    }\n\n    function balanceOf(address sender) external view returns (uint256) {\n        return erc721.balanceOf(sender);\n    }\n\n    /// @notice gets the balance of a wallet associated with a tokenId\n    function getBalanceOfWallet(uint32 tokenId) public view returns (uint256) {\n        address addr = getLink(tokenId, 0);\n        if (addr == address(0x0)) return 0;\n        (bool success, bytes memory returnData) = addr.staticcall(\n            abi.encodeWithSignature('getBalance')\n        );\n\n        if (!success) return 0;\n\n        return abi.decode(returnData, (uint256));\n    }\n\n    function get(uint32 tokenId) external view returns (InfinityObject memory) {\n        return storageController.get(tokenId);\n    }\n\n    function getWalletContract(uint32 tokenId)\n        public\n        view\n        returns (address result)\n    {\n        return getLink(tokenId, 0);\n    }\n\n    function getLink(uint32 tokenId, uint256 index)\n        public\n        view\n        returns (address)\n    {\n        if (tokenId > storageController.get(tokenId).destinations.length)\n            return address(0x0);\n\n        return storageController.get(tokenId).destinations[index];\n    }\n\n    function getStickerContract(uint32 tokenId)\n        public\n        view\n        returns (address result)\n    {\n        return getLink(tokenId, 1);\n    }\n\n    function getPreviewTimestamp(address addr) public view returns (uint256) {\n        return storageController.getPreviewTimestamp(addr);\n    }\n\n    function getPreviewCount(address addr) public view returns (uint256 count) {\n        //find previews\n        InfinityMintObject.InfinityObject[] memory previews = storageController\n            .findPreviews(addr, valuesController.tryGetValue('previewCount'));\n\n        //since mappings initialize their values at defaults we need to check if we are owner\n        count = 0;\n        for (uint256 i = 0; i < previews.length; ) {\n            if (previews[i].owner == addr) count++;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function allPreviews(address addr) external view returns (uint32[] memory) {\n        require(addr != address(0x0), 'cannot view previews for null address');\n\n        //find previews\n        InfinityMintObject.InfinityObject[] memory previews = storageController\n            .findPreviews(addr, valuesController.tryGetValue('previewCount'));\n\n        //since mappings initialize their values at defaults we need to check if we are owner\n        uint256 count = 0;\n        for (uint256 i = 0; i < previews.length; ) {\n            if (previews[i].owner == addr) count++;\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (count > 0) {\n            uint32[] memory rPreviews = new uint32[](count);\n            count = 0;\n            for (uint256 i = 0; i < previews.length; ) {\n                rPreviews[count++] = uint32(i);\n                unchecked {\n                    ++i;\n                }\n            }\n\n            return rPreviews;\n        }\n\n        return new uint32[](0);\n    }\n\n    function getPreview(uint32 index)\n        public\n        view\n        returns (InfinityObject memory)\n    {\n        return storageController.getPreviewAt(sender(), index);\n    }\n\n    function totalMints() external view returns (uint32) {\n        return erc721.currentTokenId();\n    }\n\n    //the total amount of tokens\n    function totalSupply() external view returns (uint256) {\n        return valuesController.tryGetValue('maxSupply');\n    }\n}\n"
    },
    "contracts/InfinityMintAsset.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './Asset.sol';\nimport './Authentication.sol';\n\nabstract contract InfinityMintAsset is Asset, Authentication {\n    mapping(uint256 => bool) internal disabledPaths; //disabled paths which are not picked\n    mapping(uint256 => uint256[]) internal pathSections; //what sections are to what path\n\n    //user values\n    InfinityMintValues internal valuesController;\n\n    //the token name\n    string internal tokenName = 'asset';\n    string public assetsType = 'default'; //the type of assetId is default\n\n    //path stuff\n    uint256 internal pathCount;\n    uint32[] internal pathSizes; //the amount of points in a path (used in random colour generation with SVG things)\n    uint256 internal safeDefaultReturnPath; //used in the case we cannot decide what path to randomly select we will return the value of this\n\n    uint256 internal assetId; //\n    uint256[][] internal assetsSections; //the sections to an asset\n    uint256[] internal assetRarity; //a list of asset rarity\n    uint32[] internal lastAssets; //the last selection of assets\n    uint32 internal nextPath = 0; //the next path to be minted\n    uint32 internal lastPath = 0;\n\n    //the names to pick from when generating\n    string[] public names;\n\n    //if all paths are for all sections\n    bool private flatSections = false;\n\n    constructor(address valuesContract) {\n        valuesController = InfinityMintValues(valuesContract);\n        assetRarity.push(0); //so assetId start at 1 not zero so zero can be treat as a\n    }\n\n    function setNames(string[] memory newNames) public onlyApproved {\n        names = newNames;\n    }\n\n    function resetNames() public onlyApproved {\n        delete names;\n    }\n\n    function resetAssets() public onlyApproved {\n        delete assetRarity;\n        delete assetsSections;\n        assetRarity.push(0);\n        assetId = 0;\n        flatSections = false;\n    }\n\n    function resetPaths() public onlyApproved {\n        delete pathSizes;\n        pathCount = 0;\n        safeDefaultReturnPath = 0;\n    }\n\n    function combineNames(string[] memory newNames) public onlyApproved {\n        require(newNames.length < 100);\n\n        for (uint256 i = 0; i < newNames.length; ) {\n            names.push(newNames[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function addName(string memory name) public onlyApproved {\n        names.push(name);\n    }\n\n    function setNextPathId(uint32 pathId) public virtual override onlyApproved {\n        nextPath = pathId;\n    }\n\n    function setLastPathId(uint32 pathId) public virtual override onlyApproved {\n        lastPath = pathId;\n    }\n\n    function getNextPath() external view virtual override returns (uint32) {\n        return nextPath;\n    }\n\n    function setLastAssets(\n        uint32[] memory assets\n    ) public virtual override onlyApproved {\n        lastAssets = assets;\n    }\n\n    function getPathSections(\n        uint256 pathId\n    ) external view virtual returns (uint256[] memory) {\n        return pathSections[pathId];\n    }\n\n    function getSectionAssets(\n        uint256 sectionId\n    ) external view returns (uint256[] memory) {\n        return assetsSections[sectionId];\n    }\n\n    function setPathSize(uint32 pathId, uint32 pathSize) public onlyApproved {\n        pathSizes[pathId] = pathSize;\n    }\n\n    function setPathSizes(uint32[] memory newPathSizes) public onlyApproved {\n        pathSizes = newPathSizes;\n    }\n\n    function getPathSize(uint32 pathId) public view override returns (uint32) {\n        if (pathId >= pathSizes.length) return 1;\n\n        return pathSizes[pathId];\n    }\n\n    function getNextPathId(\n        RandomNumber randomNumberController\n    ) public virtual override returns (uint32) {\n        uint256 result = randomNumberController.getMaxNumber(pathCount);\n\n        //path is greather than token Paths\n        if (result >= pathCount) return uint32(safeDefaultReturnPath);\n\n        //count up until a non disabled path is found\n        while (disabledPaths[result]) {\n            if (result + 1 >= pathCount) result = 0;\n            result++;\n        }\n\n        return uint32(result);\n    }\n\n    function getNames(\n        uint256 nameCount,\n        RandomNumber randomNumberController\n    ) public virtual override returns (string[] memory results) {\n        string memory defaultName = getDefaultName();\n\n        // matched and incremental use nextPath to get their name\n        if (\n            !valuesController.isTrue('matchedMode') &&\n            !valuesController.isTrue('incrementalMode')\n        ) {\n            if (nameCount <= 0 && valuesController.isTrue('mustGenerateName'))\n                nameCount = 1;\n\n            if (nameCount <= 0 || names.length == 0) {\n                results = new string[](1);\n                results[0] = defaultName;\n                return results;\n            }\n\n            results = new string[](nameCount + 1);\n\n            for (uint32 i = 0; i < nameCount; ) {\n                uint256 result = randomNumberController.getMaxNumber(\n                    names.length\n                );\n\n                if (result >= names.length) result = 0;\n                results[i] = names[result];\n\n                unchecked {\n                    ++i;\n                }\n            }\n            results[nameCount] = defaultName;\n        } else {\n            results = new string[](2);\n\n            if (names.length == 0) results[0] = '';\n            else if (nextPath < names.length) results[0] = names[nextPath];\n            else results[0] = names[0];\n            results[1] = defaultName;\n        }\n    }\n\n    function getMintData(\n        uint32,\n        uint32,\n        RandomNumber\n    ) public virtual override returns (bytes memory) {\n        return '{}'; //returns a blank json array\n    }\n\n    function getDefaultName()\n        internal\n        virtual\n        override\n        returns (string memory)\n    {\n        return tokenName;\n    }\n\n    function isValidPath(uint32 pathId) public view override returns (bool) {\n        return (pathId >= 0 && pathId < pathCount && !disabledPaths[pathId]);\n    }\n\n    function pickPath(\n        uint32 pathId,\n        uint32 currentTokenId,\n        RandomNumber randomNumberController\n    ) public virtual override returns (PartialStruct memory) {\n        setNextPathId(pathId);\n        setLastAssets(getRandomAsset(pathId, randomNumberController));\n\n        return\n            PartialStruct(\n                pathId,\n                getPathSize(pathId),\n                lastAssets,\n                getNames(\n                    randomNumberController.getMaxNumber(\n                        valuesController.tryGetValue('nameCount')\n                    ),\n                    randomNumberController\n                ),\n                getColours(pathId, randomNumberController),\n                getMintData(pathId, currentTokenId, randomNumberController)\n            );\n    }\n\n    function pickPath(\n        uint32 currentTokenId,\n        RandomNumber randomNumberController\n    ) public virtual override returns (PartialStruct memory) {\n        return\n            pickPath(\n                getNextPathId(randomNumberController),\n                currentTokenId,\n                randomNumberController\n            );\n    }\n\n    function getRandomAsset(\n        uint32 pathId,\n        RandomNumber randomNumberController\n    ) public view virtual override returns (uint32[] memory assetsId) {\n        if (assetId == 0) {\n            return assetsId;\n        }\n\n        uint256[] memory sections;\n        if (flatSections) sections = pathSections[0];\n        else sections = pathSections[pathId];\n\n        //index position of sections\n        uint256 indexPosition = 0;\n        //current random number salt\n        uint256 salt = randomNumberController.salt();\n\n        if (sections.length == 0) {\n            return assetsId;\n        } else {\n            assetsId = new uint32[](sections.length);\n            uint32[] memory selectedPaths;\n            uint256[] memory section;\n            for (uint256 i = 0; i < sections.length; ) {\n                section = assetsSections[sections[i]];\n\n                if (section.length == 0) {\n                    assetsId[indexPosition++] = 0;\n                    unchecked {\n                        ++i;\n                    }\n                    continue;\n                }\n\n                if (section.length == 1 && assetRarity[section[0]] == 100) {\n                    assetsId[indexPosition++] = uint32(section[0]);\n                    unchecked {\n                        ++i;\n                    }\n                    continue;\n                }\n\n                selectedPaths = new uint32[](section.length);\n                //repeat filling array with found values\n                uint256 count = 0;\n\n                for (uint256 index = 0; index < section.length; ) {\n                    if (count == selectedPaths.length) break;\n                    if (section[index] == 0) {\n                        unchecked {\n                            ++index;\n                        }\n                        continue;\n                    }\n\n                    uint256 rarity = 0;\n\n                    if (assetRarity.length > section[index])\n                        rarity = assetRarity[section[index]];\n\n                    if (\n                        (rarity == 100 ||\n                            rarity >\n                            randomNumberController.returnNumber(\n                                100,\n                                i +\n                                    index +\n                                    rarity +\n                                    count +\n                                    salt +\n                                    indexPosition\n                            ))\n                    ) selectedPaths[count++] = uint32(section[index]);\n\n                    unchecked {\n                        ++index;\n                    }\n                }\n\n                //pick an asset\n                uint256 result = 0;\n\n                if (count <= 1) assetsId[indexPosition++] = selectedPaths[0];\n                else if (count >= 2) {\n                    result = randomNumberController.returnNumber(\n                        count,\n                        selectedPaths.length + count + indexPosition + salt\n                    );\n                    if (result < selectedPaths.length)\n                        assetsId[indexPosition++] = selectedPaths[result];\n                    else assetsId[indexPosition++] = 0;\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n\n    function setSectionAssets(\n        uint32 sectionId,\n        uint256[] memory _assets\n    ) public onlyDeployer {\n        assetsSections[sectionId] = _assets;\n    }\n\n    function pushSectionAssets(uint256[] memory _assets) public onlyDeployer {\n        assetsSections.push(_assets);\n    }\n\n    function flatPathSections(uint32[] memory pathIds) public onlyDeployer {\n        pathSections[0] = pathIds;\n        flatSections = true;\n    }\n\n    function setPathSections(\n        uint32[] memory pathIds,\n        uint256[][] memory _sections\n    ) public onlyDeployer {\n        require(pathIds.length == _sections.length);\n\n        for (uint256 i = 0; i < pathIds.length; i++) {\n            pathSections[pathIds[i]] = _sections[i];\n        }\n    }\n\n    function addAssets(uint256[] memory rarities) public onlyDeployer {\n        for (uint256 i = 0; i < rarities.length; ) {\n            if (rarities[i] > 100) revert('one of more rarities are above 100');\n            assetRarity.push(rarities[i]);\n            //increment asset counter\n            assetId += 1;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function addAsset(uint256 rarity) public virtual override onlyDeployer {\n        if (rarity > 100) revert();\n\n        //increment asset counter\n        assetRarity.push(rarity);\n        assetId += 1;\n    }\n\n    //returns randomised colours for SVG Paths\n    function getColours(\n        uint32 pathId,\n        RandomNumber randomNumberController\n    ) public virtual override returns (uint32[] memory result) {\n        uint32 pathSize = getPathSize(pathId);\n        uint256 div = valuesController.tryGetValue('colourChunkSize');\n\n        if (div <= 0) div = 4;\n\n        if (pathSize <= div) {\n            result = new uint32[](4);\n            result[0] = uint32(randomNumberController.getMaxNumber(0xFFFFFF));\n            result[1] = pathSize;\n            result[2] = uint32(randomNumberController.getMaxNumber(0xFFFFFFFF));\n            result[3] = uint32(valuesController.tryGetValue('extraColours'));\n            return result;\n        }\n\n        uint32 groups = uint32(1 + (pathSize / div));\n        uint32 size = (groups * 2);\n        uint32 tempPathSize = (pathSize);\n        uint256 count = 0;\n        result = new uint32[](size + 2);\n        for (uint256 i = 0; i < size; ) {\n            if (i == 0 || i % 2 == 0)\n                result[i] = uint32(\n                    randomNumberController.getMaxNumber(0xFFFFFF)\n                );\n            else {\n                uint256 tempResult = tempPathSize - (div * count++);\n                result[i] = uint32(tempResult > div ? div : tempResult);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        result[result.length - 2] = uint32(\n            randomNumberController.getMaxNumber(0xFFFFFFFF)\n        );\n        result[result.length - 1] = uint32(\n            valuesController.tryGetValue('extraColours')\n        );\n    }\n\n    function setPathDisabled(uint32 pathId, bool value) public onlyApproved {\n        //if path zero is suddenly disabled, we need a new safe path to return\n        if (pathId == safeDefaultReturnPath && value) {\n            uint256 val = (safeDefaultReturnPath);\n            while (disabledPaths[val]) {\n                if (val >= pathCount) val = safeDefaultReturnPath;\n                val++;\n            }\n            safeDefaultReturnPath = val;\n        }\n\n        //if we enable zero again then its safe to return 0\n        if (pathId <= safeDefaultReturnPath && value)\n            safeDefaultReturnPath = pathId;\n\n        disabledPaths[pathId] = value;\n    }\n\n    function setPathCount(uint256 newPathCount) public onlyApproved {\n        pathCount = newPathCount;\n    }\n}\n"
    },
    "contracts/InfinityMintLinker.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './Authentication.sol';\nimport './IntegrityInterface.sol';\nimport './InfinityMintStorage.sol';\n\n/// @title InfinityMint Linker\n/// @author 0xTinman.eth\n/// @notice Serves as a utility contract which manages the destinations field of an InfinityMint token\n/// @dev Allows content owners to add pre-validated links the user can add to their destinations field, contract creator sets links through build tools\ncontract InfinityMintLinker is Authentication, InfinityMintObject {\n    /// @notice the location of the main ERC721 contract\n    address public erc721Location;\n    /// @notice location of the storage contract\n    InfinityMintStorage internal storageController;\n    /// @notice holds all of the links its length is linkCount\n    mapping(uint256 => Link) internal links;\n    /// @notice the length of links mapping or the amount of links setup\n    uint256 linkCount = 0;\n\n    struct Link {\n        uint256 index;\n        bytes versionType;\n        bytes4 interfaceId;\n        string key;\n        bool erc721;\n        bool verifyIntegrity;\n        bool forcedOnly;\n        bool permanent;\n        bool active;\n    }\n\n    constructor(address _storageDestination, address erc721Destination) {\n        storageController = InfinityMintStorage(_storageDestination);\n        erc721Location = erc721Destination;\n    }\n\n    function getLink(uint256 index) external view returns (Link memory) {\n        require(bytes(links[index].key).length != 0, 'link is invalid');\n        return links[index];\n    }\n\n    function getLinkByKey(string calldata key)\n        external\n        view\n        returns (Link memory)\n    {\n        return requireLinkFromKey(key);\n    }\n\n    function addSupport(\n        uint256 index,\n        string memory key,\n        bytes memory versionType,\n        bool isErc721,\n        bool verifyIntegrity,\n        bool forcedOnly,\n        bool permanent\n    ) public onlyApproved {\n        require(index < 32, 'can only have a maximum index of 32');\n        require(links[index].active != true, 'link already established');\n        links[index] = Link(\n            index,\n            versionType,\n            type(IntegrityInterface).interfaceId,\n            key,\n            isErc721,\n            verifyIntegrity,\n            forcedOnly,\n            permanent,\n            true\n        );\n        unchecked {\n            linkCount++;\n        }\n    }\n\n    /// @notice disables this link from being used in the future\n    function toggleSupport(uint256 index) public onlyApproved {\n        require(bytes(links[index].key).length != 0, 'invalid link');\n        links[index].active = false;\n    }\n\n    /// @notice used by build tools to redeploy\n    function clearLinks() public onlyDeployer {\n        for (uint256 i = 0; i < linkCount; ) {\n            if (links[i].active) links[i].active = false;\n            unchecked {\n                ++i;\n            }\n        }\n\n        linkCount = 0;\n    }\n\n    function changeLinkKey(string calldata keyToChange, string calldata key)\n        public\n        onlyApproved\n    {\n        Link memory tempLink = requireLinkFromKey(keyToChange);\n        require(\n            hasKey(key) == false,\n            'cannot change key to that key as that key already exists'\n        );\n\n        tempLink.key = key;\n        links[tempLink.index] = tempLink;\n    }\n\n    function hasKey(string calldata key) internal view returns (bool) {\n        require(bytes(key).length != 0, 'blank key');\n\n        for (uint256 i = 0; i < linkCount; ) {\n            if (\n                InfinityMintUtil.isEqual(bytes(links[i].key), bytes(key)) &&\n                links[i].active\n            ) return true;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return false;\n    }\n\n    /// @notice gets link type from string key name\n    /// @dev if two or more keys are present with the same name then this is designed to return the newest object which has been added.\n    function requireLinkFromKey(string calldata key)\n        internal\n        view\n        returns (Link memory)\n    {\n        require(bytes(key).length != 0, 'blank key');\n\n        Link memory tempLink;\n        bool hasFound = false;\n        for (uint256 i = 0; i < linkCount; ) {\n            if (\n                InfinityMintUtil.isEqual(bytes(links[i].key), bytes(key)) &&\n                links[i].active\n            ) {\n                hasFound = true;\n                tempLink = links[i];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        require(hasFound, 'key invalid');\n        return tempLink;\n    }\n\n    /// @notice has to be called by token owner\n    function setLink(\n        uint256 tokenId,\n        string calldata key,\n        address destination\n    ) public {\n        require(isApprovedOrOwner(sender(), tokenId), 'not owner');\n        _setLink(tokenId, key, destination);\n    }\n\n    /// @notice Can be called by other contracts who are approved\n    function forceLink(\n        uint256 tokenId,\n        string calldata key,\n        address destination\n    ) public onlyApproved {\n        Link memory link = requireLinkFromKey(key); // will throw\n        InfinityObject memory token = storageController.get(uint32(tokenId)); // will throw\n\n        if (token.destinations.length == 0) {\n            token.destinations = new address[](link.index + 1);\n            token.destinations[link.index] = destination;\n        } else {\n            if (link.index >= token.destinations.length) {\n                address[] memory tempCopy = new address[](link.index + 1);\n                for (uint256 i = 0; i < tempCopy.length; ) {\n                    if (i == link.index) tempCopy[i] = destination;\n                    else if (\n                        i < token.destinations.length &&\n                        token.destinations[i] != address(0x0)\n                    ) tempCopy[i] = token.destinations[i];\n\n                    unchecked {\n                        ++i;\n                    }\n                }\n\n                token.destinations = tempCopy;\n            } else {\n                token.destinations[link.index] = destination;\n            }\n        }\n\n        storageController.set(uint32(tokenId), token);\n    }\n\n    function unlink(uint256 tokenId, string calldata key) public {\n        require(isApprovedOrOwner(sender(), tokenId), 'not owner');\n\n        Link memory link = requireLinkFromKey(key); // will throw\n        InfinityObject memory token = storageController.get(uint32(tokenId)); // will throw\n        require(link.permanent != true, 'link can never be unlinked');\n        require(\n            link.forcedOnly != true,\n            'link must be managed through an external contract'\n        );\n\n        //the first two indexes should always be index 0 (wallet) and index 1 (stickers), the erc721\n        //will set a token flag allowing you to unlink the contracts upon transfer unless it is\n        //disabled in the values controller. it is up to the deployer to decide if they will\n        //allow people to unlink the wallet/sticker when they transfer, bare in mind this does\n        //potentially allow them to transfer the token, unlink and re-establish new links\n        //burning eads contracts.\n        require(\n            link.index != 0 ||\n                storageController.flag(tokenId, 'canUnlinkIndex0'),\n            'index 0 cannot be unlinked at this time'\n        );\n        require(\n            link.index != 1 ||\n                storageController.flag(tokenId, 'canUnlinkIndex1'),\n            'index 1 cannot be unlinked at this time'\n        );\n\n        token.destinations[link.index] = address(0x0);\n        storageController.set(uint32(tokenId), token);\n    }\n\n    function _setLink(\n        uint256 tokenId,\n        string calldata key,\n        address destination\n    ) internal {\n        Link memory link = requireLinkFromKey(key); // will throw\n        InfinityObject memory token = storageController.get(uint32(tokenId)); // will throw\n\n        //must be set by another contract\n        require(link.forcedOnly != true, 'cannot be set by linker');\n        //if the destinations isnt zero require it to be a new index or an unmapped but created inex\n        if (token.destinations.length != 0) {\n            require(\n                link.index >= token.destinations.length ||\n                    token.destinations[link.index] == address(0x0),\n                'destination already set'\n            );\n        }\n\n        // for stuff like ENS Registry contracts and the like outside of InfinityMint we can chose not to verify\n        if (link.verifyIntegrity) {\n            (\n                address from,\n                address _deployer,\n                uint256 _tokenId,\n                bytes memory versionType,\n                bytes4 interfaceId\n            ) = IntegrityInterface(destination).getIntegrity();\n\n            require(_deployer == sender(), 'mismatch 0');\n            require(from == destination, 'mismatch 1');\n            require(tokenId == _tokenId, 'mismatch 2');\n            require(\n                InfinityMintUtil.isEqual(versionType, link.versionType),\n                'mismatch 3'\n            );\n            require(interfaceId == link.interfaceId, 'mismatch 4');\n        }\n\n        if (token.destinations.length == 0) {\n            token.destinations = new address[](link.index + 1);\n            token.destinations[link.index] = destination;\n        } else {\n            if (link.index + 1 >= token.destinations.length) {\n                address[] memory tempCopy = new address[](link.index + 1);\n                for (uint256 i = 0; i < tempCopy.length; ) {\n                    if (i == link.index) tempCopy[i] = destination;\n                    else if (i < token.destinations.length)\n                        tempCopy[i] = token.destinations[i];\n\n                    unchecked {\n                        ++i;\n                    }\n                }\n\n                token.destinations = tempCopy;\n            } else {\n                token.destinations[link.index] = destination;\n            }\n        }\n\n        storageController.set(uint32(tokenId), token);\n    }\n\n    /// @notice gets token\n    /// @dev erc721 address must be ERC721 implementor.\n    function isApprovedOrOwner(address owner, uint256 tokenId)\n        private\n        view\n        returns (bool)\n    {\n        (bool success, bytes memory returnData) = erc721Location.staticcall(\n            abi.encodeWithSignature(\n                'isApprovedOrOwner(address,uint256)',\n                owner,\n                tokenId\n            )\n        );\n\n        if (!success) {\n            if (returnData.length == 0) revert('is approved or owner reverted');\n            else\n                assembly {\n                    let returndata_size := mload(returnData)\n                    revert(add(32, returnData), returndata_size)\n                }\n        }\n\n        bool result = abi.decode(returnData, (bool));\n        return result == true;\n    }\n}\n"
    },
    "contracts/InfinityMintObject.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\n//this is implemented by every contract in our system\nimport './InfinityMintUtil.sol';\nimport './InfinityMintValues.sol';\n\nabstract contract InfinityMintObject {\n    /// @notice The main InfinityMint object, TODO: Work out a way for this to easily be modified\n    struct InfinityObject {\n        uint32 pathId;\n        uint32 pathSize;\n        uint32 currentTokenId;\n        address owner;\n        uint32[] colours;\n        bytes mintData;\n        uint32[] assets;\n        string[] names;\n        address[] destinations;\n    }\n\n    /// @notice Creates a new struct from arguments\n    /// @dev Stickers are not set through this, structs cannot be made with sticker contracts already set and have to be set manually\n    /// @param currentTokenId the tokenId,\n    /// @param pathId the infinity mint paths id\n    /// @param pathSize the size of the path (only for vectors)\n    /// @param assets the assets which make up the token\n    /// @param names the names of the token, its just the name but split by the splaces.\n    /// @param colours decimal colours which will be convered to hexadecimal colours\n    /// @param mintData variable dynamic field which is passed to ERC721 Implementor contracts and used in a lot of dynamic stuff\n    /// @param _sender aka the owner of the token\n    /// @param destinations a list of contracts associated with this token\n    function createInfinityObject(\n        uint32 currentTokenId,\n        uint32 pathId,\n        uint32 pathSize,\n        uint32[] memory assets,\n        string[] memory names,\n        uint32[] memory colours,\n        bytes memory mintData,\n        address _sender,\n        address[] memory destinations\n    ) internal pure returns (InfinityObject memory) {\n        return\n            InfinityObject(\n                pathId,\n                pathSize,\n                currentTokenId,\n                _sender, //the sender aka owner\n                colours,\n                mintData,\n                assets,\n                names,\n                destinations\n            );\n    }\n\n    /// @notice basically unpacks a return object into bytes.\n    function encode(InfinityObject memory data)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encode(\n                data.pathId,\n                data.pathSize,\n                data.currentTokenId,\n                data.owner,\n                abi.encode(data.colours),\n                data.mintData,\n                data.assets,\n                data.names,\n                data.destinations\n            );\n    }\n\n    /// @notice Copied behavours of the open zeppelin content due to prevent msg.sender rewrite through assembly\n    function sender() internal view returns (address) {\n        return (msg.sender);\n    }\n\n    /// @notice Copied behavours of the open zeppelin content due to prevent msg.sender rewrite through assembly\n    function value() internal view returns (uint256) {\n        return (msg.value);\n    }\n}\n"
    },
    "contracts/InfinityMintProject.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './Authentication.sol';\n\ncontract InfinityMintProject is InfinityMintObject, Authentication {\n    mapping(uint256 => bytes) internal projects;\n    mapping(uint256 => bytes) internal tags;\n    mapping(bytes => bytes) internal interactions;\n    uint256 internal nextVersion = 0;\n    uint256 internal outputVersion = 0;\n\n    function getVersions() external view returns (uint256) {\n        return nextVersion;\n    }\n\n    function getCurrentTag() external view returns (bytes memory) {\n        return tags[outputVersion];\n    }\n\n    function getCurrentVersion() external view returns (uint256) {\n        return outputVersion;\n    }\n\n    function setInitialProject(bytes memory project) public onlyDeployer {\n        require(nextVersion == 0, 'initial project already set');\n        projects[nextVersion] = project;\n        tags[nextVersion] = 'initial';\n        interactions['initial'] = abi.encode(\n            sender(),\n            block.timestamp,\n            block.number,\n            project.length\n        );\n        outputVersion = 0;\n        unchecked {\n            ++nextVersion;\n        }\n    }\n\n    function setVersion(uint256 version) public onlyApproved {\n        require(version < nextVersion && version > 0, 'invalid version');\n        require(projects[version].length != 0, 'blank project set');\n        outputVersion = version;\n    }\n\n    function getProject() external view returns (bytes memory) {\n        bytes memory result = projects[outputVersion];\n        if (result.length == 0) return bytes(\"{'local':true}\"); //try and force local infinity mint mode\n        return result;\n    }\n\n    function getUpdates() external view returns (bytes[] memory updates) {\n        updates = new bytes[](nextVersion);\n\n        for (uint256 i = 0; i < nextVersion; ) {\n            updates[i] = interactions[tags[i]];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function updateProject(\n        bytes memory project,\n        bytes memory tag,\n        bool setAsCurrentVersion\n    ) public onlyApproved {\n        require(bytes(project).length != 0, 'blank project set');\n        require(bytes(tag).length != 0, 'blank tag set');\n        require(interactions[tag].length == 0, 'tag already set');\n        require(nextVersion != 0, 'initial project not set by deployer');\n        projects[nextVersion] = project;\n        tags[nextVersion] = tag;\n        interactions[tag] = abi.encode(\n            sender(),\n            block.timestamp,\n            block.number,\n            project.length\n        );\n        unchecked {\n            if (setAsCurrentVersion) outputVersion = nextVersion;\n            ++nextVersion;\n        }\n    }\n}\n"
    },
    "contracts/InfinityMintStorage.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './InfinityMintObject.sol';\nimport './Authentication.sol';\n\n/// @title InfinityMint storage controller\n/// @author 0xTinman.eth\n/// @notice Stores the outcomes of the mint process and previews and also unlock keys\n/// @dev Attached to to an InfinityMint\ncontract InfinityMintStorage is Authentication, InfinityMintObject {\n    /// @notice previews\n    mapping(address => mapping(uint256 => InfinityObject)) public previews;\n    /// @notice previews timestamps of when new previews can be made\n    mapping(address => uint256) public previewTimestamp;\n    /// @notice all of the token data\n    mapping(uint32 => InfinityObject) private tokens;\n    /// @notice Address flags can be toggled and effect all of the tokens\n    mapping(address => mapping(string => bool)) private flags;\n    /// @notice a list of tokenFlags associated with the token\n    mapping(uint256 => mapping(string => bool)) public tokenFlags;\n    /// @notice a list of options\n    mapping(address => mapping(string => string)) private options;\n    /// @notice private mapping holding a list of tokens for owned by the address for quick look up\n    mapping(address => uint32[]) private registeredTokens;\n\n    /// @notice returns true if the address is preview blocked and unable to receive more previews\n    function getPreviewTimestamp(address addr) external view returns (uint256) {\n        return previewTimestamp[addr];\n    }\n\n    /// @notice sets a time in the future they an have more previews\n    function setPreviewTimestamp(\n        address addr,\n        uint256 timestamp\n    ) public onlyApproved {\n        require(timestamp > block.timestamp, 'timestamp must be in the future');\n        previewTimestamp[addr] = timestamp;\n    }\n\n    /**\n\t\t@notice Returns true if address in destinations array is valid,\n\t\tdestinations array is managed by InfinityMintLinker and i used to associate contract destinations on chain with a token\n\t*/\n    function hasDestinaton(\n        uint32 tokenId,\n        uint256 index\n    ) external view returns (bool) {\n        return\n            tokens[tokenId].destinations.length < index &&\n            tokens[tokenId].destinations[index] != address(0x0);\n    }\n\n    /// @notice Allows those approved with the contract to directly force a token flag. The idea is a seperate contract would control immutable this way\n    /// @dev NOTE: This can only be called by contracts to curb rugging potential\n    function forceTokenFlag(\n        uint256 tokenId,\n        string memory _flag,\n        bool position\n    ) public onlyApproved {\n        tokenFlags[tokenId][_flag] = position;\n    }\n\n    //// @notice Allows the current token owner to toggle a flag on the token, for instance, locked flag being true will mean token cannot be transfered\n    function setTokenFlag(\n        uint256 tokenId,\n        string memory _flag,\n        bool position\n    ) public onlyApproved {\n        require(this.flag(tokenId, 'immutable') != true, 'token is immutable');\n        require(\n            !InfinityMintUtil.isEqual(bytes(_flag), 'immutable'),\n            'token immutable/mutable state cannot be modified this way for security reasons'\n        );\n        tokenFlags[tokenId][_flag] = position;\n    }\n\n    /// @notice returns the value of a flag\n    function flag(\n        uint256 tokenId,\n        string memory _flag\n    ) external view returns (bool) {\n        return tokenFlags[tokenId][_flag];\n    }\n\n    /// @notice sets an option for a users tokens\n    /// @dev this is used for instance inside of tokenURI\n    function setOption(\n        address addr,\n        string memory key,\n        string memory option\n    ) public onlyApproved {\n        options[addr][key] = option;\n    }\n\n    /// @notice deletes an option\n    function deleteOption(address addr, string memory key) public onlyApproved {\n        delete options[addr][key];\n    }\n\n    /// @notice returns a global option for all the addresses tokens\n    function getOption(\n        address addr,\n        string memory key\n    ) external view returns (string memory) {\n        return options[addr][key];\n    }\n\n    //// @notice Allows the current token owner to toggle a flag on the token, for instance, locked flag being true will mean token cannot be transfered\n    function setFlag(\n        address addr,\n        string memory _flag,\n        bool position\n    ) public onlyApproved {\n        flags[addr][_flag] = position;\n    }\n\n    function tokenFlag(\n        uint32 tokenId,\n        string memory _flag\n    ) external view returns (bool) {\n        return tokenFlags[tokenId][_flag];\n    }\n\n    function validDestination(\n        uint32 tokenId,\n        uint256 index\n    ) external view returns (bool) {\n        return (tokens[tokenId].owner != address(0x0) &&\n            tokens[tokenId].destinations.length != 0 &&\n            index < tokens[tokenId].destinations.length &&\n            tokens[tokenId].destinations[index] != address(0x0));\n    }\n\n    /// @notice returns the value of a flag\n    function flag(\n        address addr,\n        string memory _flag\n    ) external view returns (bool) {\n        return flags[addr][_flag];\n    }\n\n    /// @notice returns address of the owner of this token\n    /// @param tokenId the tokenId to get the owner of\n    function getOwner(uint32 tokenId) public view returns (address) {\n        return tokens[tokenId].owner;\n    }\n\n    /// @notice returns an integer array containing the token ids owned by the owner address\n    /// @dev NOTE: This will only track 256 tokens\n    /// @param owner the owner to look for\n    function getAllRegisteredTokens(\n        address owner\n    ) public view returns (uint32[] memory) {\n        return registeredTokens[owner];\n    }\n\n    /// @notice this method adds a tokenId from the registered tokens list which is kept for the owner. these methods are designed to allow limited data retrival functionality on local host environments\n    /// @dev for local testing purposes mostly, to make it scalable the length is capped to 128. Tokens should be indexed by web2 server not on chain.\n    /// @param owner the owner to add the token too\n    /// @param tokenId the tokenId to add\n    function addToRegisteredTokens(\n        address owner,\n        uint32 tokenId\n    ) public onlyApproved {\n        //if the l\n        if (registeredTokens[owner].length < 256)\n            registeredTokens[owner].push(tokenId);\n    }\n\n    /// @notice Gets the amount of registered tokens\n    /// @dev Tokens are indexable instead by their current positon inside of the owner wallets collection, returns a tokenId\n    /// @param owner the owner to get the length of\n    function getRegisteredTokenCount(\n        address owner\n    ) public view returns (uint256) {\n        return registeredTokens[owner].length;\n    }\n\n    /// @notice returns a token\n    /// @dev returns an InfinityObject defined in {InfinityMintObject}\n    /// @param tokenId the tokenId to get\n    function get(uint32 tokenId) public view returns (InfinityObject memory) {\n        if (tokens[tokenId].owner == address(0x0)) revert('invalid token');\n\n        return tokens[tokenId];\n    }\n\n    /// @notice Sets the owner field in the token to another value\n    function transfer(address to, uint32 tokenId) public onlyApproved {\n        //set to new owner\n        tokens[tokenId].owner = to;\n    }\n\n    function set(\n        uint32 tokenId,\n        InfinityObject memory data\n    ) public onlyApproved {\n        require(data.owner != address(0x0), 'null owner');\n        require(data.currentTokenId == tokenId, 'tokenID mismatch');\n        tokens[tokenId] = data;\n    }\n\n    /// @notice use normal set when can because of the checks it does before the set, this does no checks\n    function setUnsafe(uint32 tokenId, bytes memory data) public onlyApproved {\n        tokens[tokenId] = abi.decode(data, (InfinityObject));\n    }\n\n    function setPreview(\n        address owner,\n        uint256 index,\n        InfinityObject memory data\n    ) public onlyApproved {\n        previews[owner][index] = data;\n    }\n\n    function getPreviewAt(\n        address owner,\n        uint256 index\n    ) external view returns (InfinityObject memory) {\n        require(\n            previews[owner][index].owner != address(0x0),\n            'invalid preview'\n        );\n\n        return previews[owner][index];\n    }\n\n    function findPreviews(\n        address owner,\n        uint256 previewCount\n    ) public view onlyApproved returns (InfinityObject[] memory) {\n        InfinityObject[] memory temp = new InfinityObject[](previewCount);\n        for (uint256 i = 0; i < previewCount; ) {\n            temp[i] = previews[owner][i];\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return temp;\n    }\n\n    function deletePreview(\n        address owner,\n        uint256 previewCount\n    ) public onlyApproved {\n        for (uint256 i = 0; i < previewCount; ) {\n            delete previews[owner][i];\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        delete previewTimestamp[owner];\n    }\n\n    function deleteFromRegisteredTokens(\n        address owner,\n        uint32 tokenId\n    ) public onlyApproved {\n        uint256 length = registeredTokens[owner].length;\n        for (uint256 i = 0; i < length; ) {\n            if (registeredTokens[owner][i] == tokenId) {\n                registeredTokens[owner][i] = registeredTokens[owner][\n                    length - 1\n                ];\n                registeredTokens[owner].pop();\n                break;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/InfinityMintUtil.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nlibrary InfinityMintUtil {\n    function toString(\n        uint256 _i\n    ) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return '0';\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    function filepath(\n        string memory directory,\n        string memory file,\n        string memory extension\n    ) internal pure returns (string memory) {\n        return string.concat(directory, file, extension);\n    }\n\n    //checks if two strings (or bytes) are equal\n    function isEqual(bytes memory s1, bytes memory s2) external pure returns (bool) {\n    if (s1.length != s2.length) return false;\n    for (uint256 i = 0; i < s1.length; i++) {\n        if (s1[i] != s2[i]) return false;\n    }\n    return true;\n}\n\n}\n"
    },
    "contracts/InfinityMintValues.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\ncontract InfinityMintValues {\n    mapping(string => uint256) private values;\n    mapping(string => bool) private booleanValues;\n    mapping(string => bool) private registeredValues;\n\n    address deployer;\n\n    constructor() {\n        deployer = msg.sender;\n    }\n\n    modifier onlyDeployer() {\n        if (msg.sender != deployer) revert();\n        _;\n    }\n\n    function setValue(string memory key, uint256 value) public onlyDeployer {\n        values[key] = value;\n        registeredValues[key] = true;\n    }\n\n    function setupValues(\n        string[] memory keys,\n        uint256[] memory _values,\n        string[] memory booleanKeys,\n        bool[] memory _booleanValues\n    ) public onlyDeployer {\n        require(keys.length == _values.length);\n        require(booleanKeys.length == _booleanValues.length);\n        for (uint256 i = 0; i < keys.length; i++) {\n            setValue(keys[i], _values[i]);\n        }\n\n        for (uint256 i = 0; i < booleanKeys.length; i++) {\n            setBooleanValue(booleanKeys[i], _booleanValues[i]);\n        }\n    }\n\n    function setBooleanValue(string memory key, bool value)\n        public\n        onlyDeployer\n    {\n        booleanValues[key] = value;\n        registeredValues[key] = true;\n    }\n\n    function isTrue(string memory key) external view returns (bool) {\n        return booleanValues[key];\n    }\n\n    function getValue(string memory key) external view returns (uint256) {\n        if (!registeredValues[key]) revert('Invalid Value');\n\n        return values[key];\n    }\n\n    /// @dev Default value it returns is zero\n    function tryGetValue(string memory key) external view returns (uint256) {\n        if (!registeredValues[key]) return 0;\n\n        return values[key];\n    }\n}\n"
    },
    "contracts/InfinityMintWallet.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './Authentication.sol';\nimport './IERC721.sol';\nimport './IntegrityInterface.sol';\n\ncontract InfinityMintWallet is\n    Authentication,\n    IERC721Receiver,\n    IntegrityInterface\n{\n    /// @notice the version type of wallet this is\n    bytes public walletType = 'Wallet';\n    /// @notice the location of the main ERC721 contract this wallet was spawned from;\n    address public erc721;\n    /// @notice the main ERC721 contract this wallet is attached too\n    uint32 public currentTokenId;\n    /// @notice the value/balance of the current wallet\n    uint256 private walletValue;\n\n    /// @notice Fired when a deposit is made\n    event Deposit(address indexed sender, uint256 amount, uint256 newTotal);\n    /// @notice Fired with a withdraw is made\n    event Withdraw(address indexed sender, uint256 amount, uint256 newTotal);\n\n    /// @notice Creates new wallet contract, tokenId refers to the ERC721 contract this wallet was spawned from.\n    /// @dev makes the owner field the owner of the contract not the deployer.\n    /// @param tokenId the tokenId from the main ERC721 contract\n    /// @param erc721Destination the main ERC721 contract\n    constructor(uint32 tokenId, address erc721Destination) Authentication() {\n        //this only refers to being allowed to deposit into the wallet\n        currentTokenId = tokenId;\n        erc721 = erc721Destination;\n        walletValue = 0;\n    }\n\n    /// @notice used by InfinityMintLinker to verify this contract is the one it says\n    function getIntegrity()\n        public\n        view\n        virtual\n        returns (\n            address,\n            address,\n            uint256,\n            bytes memory,\n            bytes4\n        )\n    {\n        return (\n            address(this),\n            deployer,\n            currentTokenId,\n            'wallet', //no version type with wallet\n            type(IntegrityInterface).interfaceId\n        );\n    }\n\n    /// @notice Opts in this contract to receipt ERC721\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    /**\n\t\t@notice This can be called by the new token owner at any time and it will match the current owner of the contract to the tokenId,\n\t\tin all cases the wallet will still be attached to the owner of the tokenId and when its not it will simply move over permissions of\n\t\tthe contract to the new owner\n\t */\n    function transferOwnershipToTokenOwner() public onlyOnce {\n        address owner = IERC721(erc721).ownerOf(currentTokenId);\n        require(deployer != owner, 'owner of the token is the deployer');\n        require(msg.sender == owner, 'sender must be the new owner');\n\n        transferOwnership(owner);\n    }\n\n    function transfer(\n        address erc721Destination,\n        address to,\n        uint256 tokenId\n    ) public onlyApproved {\n        (bool success, bytes memory returnData) = erc721Destination.call{\n            value: 0\n        }(\n            abi.encodeWithSignature(\n                'transfer(address,address,uint256)',\n                address(this),\n                address(to),\n                tokenId\n            )\n        );\n\n        if (!success) {\n            if (returnData.length == 0) revert('call reverted');\n            else\n                assembly {\n                    let returndata_size := mload(returnData)\n                    revert(add(32, returnData), returndata_size)\n                }\n        }\n    }\n\n    /// @notice Returns the balance of the wallet\n    function getBalance() public view returns (uint256) {\n        return walletValue;\n    }\n\n    /// @notice Allows anyone to deposit ERC20 into this wallet.\n    function deposit() public payable onlyOnce {\n        uint256 value = (msg.value);\n        require(value >= 0);\n\n        walletValue = walletValue + value;\n        emit Deposit(msg.sender, value, walletValue);\n    }\n\n    /// @notice Allows you to withdraw\n    function withdraw() public onlyOnce onlyApproved {\n        //to stop re-entry attack\n        uint256 balance = (walletValue);\n        walletValue = 0;\n        payable(deployer).transfer(balance);\n        emit Withdraw(msg.sender, address(this).balance, walletValue);\n    }\n}\n"
    },
    "contracts/IntegrityInterface.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\ninterface IntegrityInterface {\n    /**\n\t\t@notice Verifys that a deployed contract matches the one we want.\n\t */\n    function getIntegrity()\n        external\n        returns (\n            address from,\n            address owner,\n            uint256 tokenId,\n            bytes memory versionType,\n            bytes4 intefaceId\n        );\n}\n"
    },
    "contracts/legacy/EADStickers.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './Stickers.sol';\nimport '../ERC721.sol';\nimport '../IntegrityInterface.sol';\n\n/// @title InfinityMint Ethereum Ad Service Sticker ERC721\n/// @author 0xTinman.eth\n/// @notice This is an ERC721 contract powering eads stickers, these are attached to every token minted by InfinityMint.\n/// @dev\ncontract EADStickers is Stickers, ERC721 {\n    /// @notice the erc721 token id must reference this contracts address\n    uint256 public erc721TokenId;\n\n    /// @notice Emitted when a request is accepted\n    event EASRequestAccepted(\n        uint32 stickerId,\n        address indexed sender,\n        uint256 price,\n        bytes packed\n    );\n    /// @notice Emitted when a request is denied\n    event EASRequestDenied(\n        uint32 requestId,\n        address indexed sender,\n        uint256 price,\n        bytes packed\n    );\n    /// @notice Emitted when a request is withdrew\n    event EASRequestWithdrew(\n        uint32 requestId,\n        address indexed sender,\n        uint256 price,\n        bytes packed\n    );\n    /// @notice Emitted when a request is added\n    event EASRequestAdded(\n        uint32 requestId,\n        address indexed sender,\n        uint256 price,\n        bytes packed\n    );\n    /// @notice Emitted when a request is added\n    event EASStickerUpdated(\n        uint32 requestId,\n        address indexed sender,\n        uint256 price,\n        bytes packed\n    );\n\n    /// @dev owner is made owner of this contract\n    constructor(\n        uint32 tokenId,\n        address erc721Destination,\n        address EASWalletAddress,\n        address valuesContract\n    ) ERC721('EADS Sticker', 'EADS') Stickers(valuesContract) {\n        erc721TokenId = tokenId;\n        erc721 = erc721Destination;\n        EASWallet = InfinityMintWallet(EASWalletAddress);\n        versionType = 'EADStickers'; // Should be the contract name\n    }\n\n    /**\n\t\t@notice This can be called by the new token owner at any time and it will match the current owner of the contract to the tokenId,\n\t\tin all cases the wallet will still be attached to the owner of the tokenId and when its not it will simply move over permissions of\n\t\tthe contract to the new owner\n\t */\n    function transferOwnershipToTokenOwner() public onlyOnce {\n        address owner = IERC721(erc721).ownerOf(erc721TokenId);\n        require(deployer != owner, 'owner of the token is the deployer');\n        require(msg.sender == owner, 'sender must be the new owner');\n        transferOwnership(owner);\n    }\n\n    function getIntegrity()\n        public\n        view\n        override\n        returns (\n            address,\n            address,\n            uint256,\n            bytes memory,\n            bytes4\n        )\n    {\n        return (\n            address(this),\n            deployer,\n            erc721TokenId,\n            versionType,\n            type(IntegrityInterface).interfaceId\n        );\n    }\n\n    /// @notice  Sets the ethereum ad service wallet location\n    function setWalletAddresss(address EASWalletAddress) public onlyDeployer {\n        require(isContract(EASWalletAddress), 'is not a contract');\n        require(\n            InfinityMintWallet(EASWalletAddress).deployer() == deployer,\n            'the deployer for this contract and the wallet contract must be the same'\n        );\n\n        EASWallet = InfinityMintWallet(EASWalletAddress);\n    }\n\n    /// @notice verifies that the current owner of this contract\n    function verifyAuthenticity() external view override returns (bool) {\n        //first we check if the current deployer of this contract is approved or the owner of the tokenID it is attached too\n        (bool success, bytes memory returnData) = erc721.staticcall(\n            abi.encodeWithSignature(\n                'isApprovedOrOwner(uint256,address)',\n                erc721TokenId,\n                deployer\n            )\n        );\n\n        //invalid token id\n        if (!success) return false;\n        //if we aren't, then the deployer isn't approved to the tokenId is linked too\n        if (!abi.decode(returnData, (bool))) return false;\n\n        return true;\n    }\n\n    /// @notice  Updates a sticker with new data.\n    /// @dev NOTE: Right now the deployer does not have to approve changes.\n    function updateSticker(uint32 stickerId, bytes memory packed) public {\n        address sender = (msg.sender);\n\n        require(isApprovedOrOwner(sender, uint256(stickerId))); // ERC721 permissions can update the sticker\n        require(isSafe(packed, erc721TokenId), 'your packed sticker is unsafe');\n        require(\n            enabled,\n            'stickers are not enabled right now and need to be enabled in order to update'\n        );\n\n        (, , , address theirOwner) = unpackSticker(packed);\n        (, , , address actualOwner) = unpackSticker(stickers[stickerId]);\n\n        require(theirOwner == actualOwner, 'trying to change the owner');\n\n        stickers[stickerId] = packed;\n    }\n\n    /// @notice See {ERC721}\n    function beforeTransfer(\n        address,\n        address to,\n        uint256 _tokenId\n    ) internal override {\n        uint32 tokenId = uint32(_tokenId);\n\n        (, string memory checkSum, string memory object, ) = unpackSticker(\n            stickers[tokenId]\n        );\n\n        //save the sticker to point to the new owner\n        stickers[tokenId] = abi.encode(tokenId, checkSum, object, to);\n    }\n\n    /// @notice Burns a sticker\n    /// @dev will delete a sticker forever\n    function burn(uint32 stickerId) public {\n        require(isApprovedOrOwner(_sender(), stickerId));\n\n        delete stickers[stickerId]; //delete the data for the sticker\n        delete approvedTokens[stickerId]; //delete approved\n\n        tokens[stickerId] = address(0x0);\n        balance[_sender()] -= 1;\n    }\n\n    /// @notice  Accepts a sticker request, minting it as an ERC721\n    /// @dev The index is relative to the amount of stickers the address has sent.\n    function acceptRequest(address sender, uint32 index)\n        public\n        override\n        onlyApproved\n        onlyOnce\n    {\n        require(requests[sender][index].length != 0);\n\n        (uint256 price, address savedSender, bytes memory packed) = abi.decode(\n            requests[sender][index],\n            (uint256, address, bytes)\n        );\n        require(sender == savedSender, 'sender and saved sender are different');\n\n        //mint the sticker\n        ERC721.mint(savedSender, currentStickerId, packed);\n        //save the sticker\n        stickers[currentStickerId] = abi.encode(price, savedSender, packed);\n\n        //send the royalty\n        //if the price is greater than 100 wei or zero, we hit back the parent ERC721 with the royalty cut\n        if (\n            (price > 100 || price == 0) &&\n            valuesController.tryGetValue('stickerSplit') >= 2\n        ) {\n            //this is what we went back to parent ERC721\n            uint256 cut = 0;\n\n            //if the price is not equal to zero, do the math.\n            if (price != 0) {\n                cut =\n                    (price / 100) *\n                    valuesController.tryGetValue('stickerSplit');\n\n                //deduct the cut from the value that the deployer holds onto\n                if (price - cut > 0) price = price - cut;\n                //else set the cut to zero\n            }\n\n            (bool success, bytes memory returnData) = address(erc721).call{\n                value: cut\n            }(\n                abi.encodeWithSignature(\n                    'depositStickerRoyalty(uint32)',\n                    erc721TokenId\n                )\n            );\n\n            if (!success) {\n                if (returnData.length == 0)\n                    revert('cannot deposit royalty to main ERC721');\n                else\n                    assembly {\n                        let returndata_size := mload(returnData)\n                        revert(add(32, returnData), returndata_size)\n                    }\n            }\n\n            //send it to the wallet currently associated with this sticker contract\n            EASWallet.deposit{ value: price }();\n        }\n\n        //delete the old now acccepted request\n        deleteRequest(sender, index);\n        //emit\n        emit EASRequestAccepted(currentStickerId++, sender, price, packed);\n    }\n\n    /// @notice  Returns the tokenURI for the sticker objects\n    /// @dev Will use the sticker object as a tokenURI if none is set.\n    function tokenURI(uint256 stickerId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        if (\n            bytes(uri[stickerId]).length == 0 &&\n            stickers[uint32(stickerId)].length == 0\n        ) revert('Token URI for non existent token');\n\n        if (bytes(uri[stickerId]).length != 0) return uri[stickerId];\n\n        require(\n            isSafe(stickers[uint32(stickerId)], erc721TokenId),\n            'request is not safely packed'\n        );\n\n        (, , string memory object, ) = unpackSticker(\n            stickers[uint32(stickerId)]\n        );\n\n        return object;\n    }\n\n    /// @notice  Adds a sticker request for the owner to accept.\n    /// @dev Its up to the end user to validate the sticker and make sure it is safe. We do various validation and check summing to make sure things are okay.\n    function addRequest(bytes memory packed) public payable override onlyOnce {\n        require(msg.value == stickerPrice, 'not the sticker price');\n        require(isSafe(packed, erc721TokenId), 'your packed sticker is unsafe');\n        require(enabled, 'no new stickers can be added right now');\n        address sender = (msg.sender);\n        require(\n            balanceOf(msg.sender) < 100,\n            'you have minted the maximum amount of stickers to this wallet, use another wallet to mint more.'\n        );\n\n        //add it!\n        requests[sender].push(abi.encode(msg.value, sender, packed));\n        if (!hasOpenRequests(sender)) openRequests.push(sender);\n\n        emit EASRequestAdded(\n            uint32(requests[sender].length - 1),\n            sender,\n            msg.value,\n            packed\n        ); //emit\n    }\n\n    /// @notice  Withdraws a sticker request giving you back your money\n    /// @dev The index is relative to the amount of stickers the address has sent.\n    function withdrawRequest(uint32 index) public override onlyOnce {\n        address sender = (msg.sender);\n\n        require(requests[sender][index].length != 0);\n\n        (uint256 price, address savedSender, bytes memory packed) = abi.decode(\n            requests[sender][index],\n            (uint256, address, bytes)\n        );\n\n        //require the current sender and the saved sender to be the same\n        require(savedSender == sender);\n        //transfer\n        payable(savedSender).transfer(price); //transfer back the price to the sender\n        //delete the rquest\n        deleteRequest(sender, index);\n        //emit\n        emit EASRequestWithdrew(index, savedSender, price, packed);\n    }\n\n    /// @notice  Denys a sticker request sending the requestee their money back.\n    /// @dev The index is relative to the amount of stickers the address has sent.\n    function denyRequest(address sender, uint32 index)\n        public\n        override\n        onlyApproved\n        onlyOnce\n    {\n        require(requests[sender][index].length != 0);\n\n        (uint256 price, address savedSender, bytes memory packed) = abi.decode(\n            requests[sender][index],\n            (uint256, address, bytes)\n        );\n\n        //delete the request\n        deleteRequest(sender, index);\n        //send the money back to the sender of the sticker offer\n        payable(savedSender).transfer(price);\n        emit EASRequestDenied(index, sender, price, packed);\n    }\n}\n"
    },
    "contracts/legacy/StickerInterface.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\ninterface StickerInterface {\n    function acceptRequest(address sender, uint32 index) external;\n\n    function addRequest(bytes memory packed) external payable;\n\n    function withdrawRequest(uint32 index) external;\n\n    function denyRequest(address sender, uint32 index) external;\n\n    function getStickers() external view returns (uint32[] memory result);\n\n    function verifyAuthenticity() external view returns (bool);\n\n    function getSticker(uint32 stickerId)\n        external\n        view\n        returns (bytes memory result);\n\n    function getRequests() external view returns (bytes[] memory result);\n\n    function getRequestCount() external view returns (uint256);\n\n    function getStickerCount() external view returns (uint256);\n\n    function getMyRequests() external view returns (bytes[] memory result);\n}\n"
    },
    "contracts/legacy/Stickers.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport '../InfinityMintWallet.sol';\nimport './StickerInterface.sol';\nimport '../IntegrityInterface.sol';\nimport '../Authentication.sol';\n\nabstract contract Stickers is\n    StickerInterface,\n    IntegrityInterface,\n    Authentication\n{\n    /// @notice Should be the name of the contract or the name of this contract\n    bytes public versionType = 'Stickers';\n    address public erc721;\n    uint32 public currentTokenId;\n    uint256 public stickerPrice;\n    uint32 public currentStickerId;\n    address[] public openRequests;\n\n    bool internal enabled;\n\n    InfinityMintWallet public EASWallet;\n    InfinityMintValues public valuesController;\n\n    mapping(uint32 => bytes) internal flags;\n    mapping(uint32 => bytes) internal stickers;\n    mapping(address => bytes[]) internal requests;\n\n    constructor(address valuesContract) {\n        enabled = true;\n        valuesController = InfinityMintValues(valuesContract);\n        stickerPrice = 1 * valuesController.tryGetValue('baseTokenValue');\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return currentStickerId;\n    }\n\n    function verifyAuthenticity()\n        external\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return true;\n    }\n\n    function setStickerPrice(uint256 price) public onlyApproved {\n        stickerPrice = price;\n    }\n\n    function setEnabled(bool isEnabled) public onlyDeployer {\n        enabled = isEnabled;\n    }\n\n    function isStickerFlagged(\n        uint32 stickerId\n    ) external view returns (bool, string memory) {\n        if (flags[stickerId].length == 0) return (false, '');\n        return abi.decode(flags[stickerId], (bool, string));\n    }\n\n    function setFlaggedSticker(\n        uint32 stickerId,\n        bool isFlagged,\n        string memory reason\n    ) public onlyDeployer {\n        require(stickerId < currentStickerId);\n\n        if (!isFlagged && flags[stickerId].length != 0) delete flags[stickerId];\n        else flags[stickerId] = abi.encode(isFlagged, reason);\n    }\n\n    function getMyRequests() public view returns (bytes[] memory result) {\n        require(requests[msg.sender].length != 0, 'no requests'); //check if user has any requests (if not, return empty array\n        bytes[] memory temp = requests[msg.sender];\n        return temp;\n    }\n\n    function getSticker(\n        uint32 stickerId\n    ) external view override returns (bytes memory result) {\n        require(stickers[stickerId].length != 0);\n        return stickers[stickerId];\n    }\n\n    function getStickerCount() external view override returns (uint256) {\n        return uint256(currentStickerId);\n    }\n\n    function getStickers()\n        external\n        view\n        override\n        returns (uint32[] memory result)\n    {\n        uint32 count = 0;\n        for (uint32 i = 0; i < currentStickerId; ) {\n            if (stickers[i].length != 0) count++;\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (count != 0) {\n            //ceate new array with the size of count\n            result = new uint32[](count);\n            count = 0; //reset count\n            for (uint32 i = 0; i < currentStickerId; ) {\n                if (stickers[i].length != 0) result[count++] = i;\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n\n    function getRequests()\n        public\n        view\n        onlyApproved\n        returns (bytes[] memory result)\n    {\n        uint256 count = 0;\n        for (uint256 i = 0; i < openRequests.length; ) {\n            count += requests[openRequests[i]].length;\n            unchecked {\n                ++i;\n            }\n        }\n\n        result = new bytes[](count);\n        count = 0;\n        for (uint256 i = 0; i < openRequests.length; ) {\n            for (uint256 x = 0; x < requests[openRequests[i]].length; ) {\n                result[count++] = requests[openRequests[i]][x];\n\n                unchecked {\n                    ++x;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return result;\n    }\n\n    function getRequestCount() external view returns (uint256) {\n        uint256 count = 0;\n        for (uint256 i = 0; i < openRequests.length; ) {\n            count += requests[openRequests[i]].length;\n            unchecked {\n                ++i;\n            }\n        }\n        return count;\n    }\n\n    function removeFromOpenRequests(address addr) internal {\n        if (openRequests.length - 1 == 0) {\n            openRequests = new address[](0);\n            return;\n        }\n\n        address[] memory temp = new address[](openRequests.length - 1);\n        address[] memory copy = (openRequests);\n        uint256 index = 0;\n        for (uint256 i = 0; i < copy.length; ) {\n            if (copy[i] == addr) {\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            temp[index++] = copy[i];\n\n            unchecked {\n                ++i;\n            }\n        }\n        openRequests = temp;\n    }\n\n    function hasOpenRequests(address addr) internal view returns (bool) {\n        for (uint256 i = 0; i < openRequests.length; ) {\n            if (openRequests[i] == addr) return true;\n\n            unchecked {\n                ++i;\n            }\n        }\n        return false;\n    }\n\n    function isSafe(\n        bytes memory _p,\n        uint256 erc721TokenId\n    ) internal pure returns (bool) {\n        //will call exception if it is bad\n        (uint32 tokenId, , , ) = unpackSticker(_p);\n        return tokenId == erc721TokenId;\n    }\n\n    function unpackSticker(\n        bytes memory sticker\n    )\n        internal\n        pure\n        returns (\n            uint32 tokenId,\n            string memory checkSum,\n            string memory object,\n            address owner\n        )\n    {\n        return abi.decode(sticker, (uint32, string, string, address));\n    }\n\n    function deleteRequest(address sender, uint256 index) internal {\n        //if this is the last request\n        if (requests[sender].length - 1 <= 0) {\n            requests[sender] = new bytes[](0);\n            removeFromOpenRequests(sender);\n            return;\n        }\n\n        //create new temp\n        bytes[] memory temp = new bytes[](requests[sender].length - 1);\n        //copy to memory so not accessing storage\n        bytes[] memory copy = (requests[sender]);\n        uint256 count = 0; //temps index\n        //for length of copy\n        for (uint256 i = 0; i < copy.length; ) {\n            //if i !== the deleted index add it to the new temp array\n            if (i != index) temp[count++] = copy[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        //overwrite\n        requests[sender] = temp;\n\n        //remove this request\n        if (requests[sender].length == 0) removeFromOpenRequests(sender);\n    }\n}\n"
    },
    "contracts/Minter.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './Authentication.sol';\nimport './InfinityMintStorage.sol';\nimport './Asset.sol';\nimport './RandomNumber.sol';\nimport './InfinityMintObject.sol';\n\n/// @title Minter Interface\n/// @author 0xTinman.eth\n/// @notice The purpose of this interface is to lay the foundation for a minter contract designed to produce a valid InfinityObject at the end of it\n/// @dev\nabstract contract Minter is Authentication {\n    Asset public assetController;\n    InfinityMintValues public valuesController;\n    InfinityMintStorage public storageController;\n    RandomNumber public randomNumberController;\n\n    /*\n     */\n    constructor(\n        address valuesContract,\n        address storageContract,\n        address assetContract,\n        address randomNumberContract\n    ) {\n        valuesController = InfinityMintValues(valuesContract);\n        storageController = InfinityMintStorage(storageContract);\n        assetController = Asset(assetContract);\n        randomNumberController = RandomNumber(randomNumberContract);\n    }\n\n    function setAssetController(address assetContract) public onlyApproved {\n        assetController = Asset(assetContract);\n    }\n\n    function setStorageController(address storageContract) public onlyApproved {\n        storageController = InfinityMintStorage(storageContract);\n    }\n\n    function setRandomNumberController(address randomNumberContract)\n        public\n        onlyApproved\n    {\n        randomNumberController = RandomNumber(randomNumberContract);\n    }\n\n    function mint(\n        uint32 currentTokenId,\n        address sender,\n        bytes memory mintData\n    ) public virtual returns (InfinityMintObject.InfinityObject memory);\n\n    /**\n\n     */\n    function getPreview(uint32 currentTokenId, address sender)\n        external\n        virtual\n        returns (uint256 previewCount);\n\n    /*\n\n    */\n    function mintPreview(\n        uint32 index,\n        uint32 currentTokenId,\n        address sender\n    ) external virtual returns (InfinityMintObject.InfinityObject memory);\n}\n"
    },
    "contracts/minter/DefaultMinter.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './../Minter.sol';\nimport './../InfinityMintObject.sol';\n\ncontract DefaultMinter is Minter, InfinityMintObject {\n    /*\n     */\n    constructor(\n        address valuesContract,\n        address storageContract,\n        address assetContract,\n        address randomNumberContract\n    )\n        Minter(\n            valuesContract,\n            storageContract,\n            assetContract,\n            randomNumberContract\n        )\n    {}\n\n    function mintPreview(\n        uint32 index,\n        uint32 currentTokenId,\n        address sender\n    )\n        external\n        view\n        virtual\n        override\n        onlyApproved\n        returns (InfinityObject memory)\n    {\n        InfinityObject memory temp = storageController.getPreviewAt(\n            sender,\n            index\n        );\n\n        //check the owner to see if its the same\n        if (temp.owner != sender) revert('bad owner');\n        if (temp.currentTokenId != index) revert('bad index');\n\n        return\n            createInfinityObject(\n                currentTokenId,\n                temp.pathId,\n                temp.pathSize,\n                temp.assets,\n                temp.names,\n                temp.colours,\n                temp.mintData,\n                temp.owner,\n                temp.destinations\n            );\n    }\n\n    /**\n\n     */\n    function getPreview(uint32 currentTokenId, address sender)\n        external\n        virtual\n        override\n        onlyApproved\n        returns (uint256 previewCount)\n    {\n        previewCount = valuesController.tryGetValue('previewCount');\n        if (previewCount == 0) return previewCount;\n\n        uint256 nameCount = randomNumberController.getMaxNumber(\n            valuesController.tryGetValue('nameCount')\n        );\n\n        //pick parent to base previews off of\n        Asset.PartialStruct memory temp = assetController.pickPath(\n            currentTokenId,\n            randomNumberController\n        );\n\n        //return it into a real object\n        InfinityObject memory obj = createInfinityObject(\n            0, //in this context this is the \"preview Id\", and we start at zero\n            assetController.getNextPath(),\n            temp.pathSize,\n            temp.assets,\n            temp.names,\n            temp.colours,\n            temp.mintData,\n            sender,\n            new address[](0)\n        );\n\n        //store it\n        storageController.setPreview(sender, 0, obj);\n\n        //start at index 1 as we have done 0, base all future previews off of zero\n        for (uint32 i = 1; i < previewCount; ) {\n            obj.currentTokenId = i;\n            //get new assets\n            obj.assets = assetController.getRandomAsset(\n                obj.pathId,\n                randomNumberController\n            );\n            //get new colours\n            obj.colours = assetController.getColours(\n                obj.pathId,\n                randomNumberController\n            );\n            //get new names\n            obj.names = assetController.getNames(\n                nameCount,\n                randomNumberController\n            );\n\n            //store this variantion\n            storageController.setPreview(sender, i, obj);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return previewCount;\n    }\n\n    /*\n\n    */\n    function mint(\n        uint32 currentTokenId,\n        address sender,\n        bytes memory\n    ) public virtual override onlyApproved returns (InfinityObject memory) {\n        Asset.PartialStruct memory temp = assetController.pickPath(\n            currentTokenId,\n            randomNumberController\n        );\n\n        return\n            createInfinityObject(\n                currentTokenId,\n                assetController.getNextPath(),\n                temp.pathSize,\n                temp.assets,\n                temp.names,\n                temp.colours,\n                temp.mintData,\n                sender,\n                new address[](0)\n            );\n    }\n}\n"
    },
    "contracts/minter/SelectiveMinter.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './../Minter.sol';\nimport './../InfinityMintObject.sol';\n\ncontract SelectiveMinter is Minter, InfinityMintObject {\n    /*\n     */\n    constructor(\n        address valuesContract,\n        address storageContract,\n        address assetContract,\n        address randomNumberContract\n    )\n        Minter(\n            valuesContract,\n            storageContract,\n            assetContract,\n            randomNumberContract\n        )\n    {}\n\n    function mintPreview(\n        uint32 index,\n        uint32 currentTokenId,\n        address sender\n    )\n        external\n        view\n        virtual\n        override\n        onlyApproved\n        returns (InfinityObject memory)\n    {\n        InfinityObject memory temp = storageController.getPreviewAt(\n            sender,\n            index\n        );\n\n        //check the owner to see if its the same\n        if (temp.owner != sender) revert('bad owner');\n        if (temp.currentTokenId != index) revert('bad index');\n\n        return\n            createInfinityObject(\n                currentTokenId,\n                temp.pathId,\n                temp.pathSize,\n                temp.assets,\n                temp.names,\n                temp.colours,\n                temp.mintData,\n                temp.owner,\n                temp.destinations\n            );\n    }\n\n    /**\n\n     */\n    function getPreview(uint32 currentTokenId, address sender)\n        external\n        virtual\n        override\n        onlyApproved\n        returns (uint256 previewCount)\n    {\n        previewCount = valuesController.tryGetValue('previewCount');\n        if (previewCount == 0) return previewCount;\n\n        uint256 nameCount = randomNumberController.getMaxNumber(\n            valuesController.tryGetValue('nameCount')\n        );\n\n        //pick parent to base previews off of\n        Asset.PartialStruct memory temp = assetController.pickPath(\n            currentTokenId,\n            randomNumberController\n        );\n\n        //return it into a real object\n        InfinityObject memory obj = createInfinityObject(\n            0, //in this context this is the \"preview Id\", and we start at zero\n            assetController.getNextPath(),\n            temp.pathSize,\n            temp.assets,\n            temp.names,\n            temp.colours,\n            temp.mintData,\n            sender,\n            new address[](0)\n        );\n\n        //store it\n        storageController.setPreview(sender, 0, obj);\n\n        //start at index 1 as we have done 0, base all future previews off of zero\n        for (uint32 i = 1; i < previewCount; ) {\n            obj.currentTokenId = i;\n            //get new assets\n            obj.assets = assetController.getRandomAsset(\n                obj.pathId,\n                randomNumberController\n            );\n            //get new colours\n            obj.colours = assetController.getColours(\n                obj.pathId,\n                randomNumberController\n            );\n            //get new names\n            obj.names = assetController.getNames(\n                nameCount,\n                randomNumberController\n            );\n\n            //store this variantion\n            storageController.setPreview(sender, i, obj);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return previewCount;\n    }\n\n    /*\n\n    */\n    function mint(\n        uint32 currentTokenId,\n        address sender,\n        bytes memory mintData\n    ) public virtual override onlyApproved returns (InfinityObject memory) {\n        Asset.PartialStruct memory temp = assetController.pickPath(\n            abi.decode(mintData, (uint32)),\n            currentTokenId,\n            randomNumberController\n        );\n\n        return\n            createInfinityObject(\n                currentTokenId,\n                assetController.getNextPath(),\n                temp.pathSize,\n                temp.assets,\n                temp.names,\n                temp.colours,\n                temp.mintData,\n                sender,\n                new address[](0)\n            );\n    }\n}\n"
    },
    "contracts/NewStickers.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './ERC721.sol';\nimport './StickerOracle.sol';\nimport './Authentication.sol';\nimport './IntegrityInterface.sol';\n\ncontract NewStickers is ERC721, Authentication, IntegrityInterface {\n    //has run a sucesful setup call\n\n    //public vars\n    StickerOracle public stickerOracle;\n    address public erc721Destination;\n    uint256 public tokenId;\n    mapping(uint256 => Sticker) public stickers;\n\n    //internal vars\n    uint256 internal stickerId;\n    mapping(uint256 => bytes) internal requests;\n    string internal options; //allows a options object to be attached to this sticker control to specify various settings, like\n    // for instance the price to submit a sticker or other shit they would like\n    bool internal hasSetup; //initially will be to false and will not allow anybody to post sticker requests until the owner\n\n    struct Sticker {\n        uint256 stickerId;\n        uint256 oracaleId;\n        address owner;\n        string stickerUri;\n        bool utility; //if true, utility tokens are accepted onto the ERC721 for free.\n        uint256 duration; //the length the sticker should stay on the token in seconds\n        uint256 pps; //price per second\n        uint256 creation;\n        bool active;\n        bool completed;\n        bool valid;\n    }\n\n    constructor(\n        address oracleDestination,\n        address erc721,\n        uint256 _tokenId,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) ERC721(tokenName, tokenSymbol) {\n        stickerOracle = StickerOracle(oracleDestination);\n        erc721Destination = erc721;\n        tokenId = _tokenId;\n    }\n\n    /// @notice allows the owner of the contract to set a json array full of settings and other data on chain also takes IPFS url\n    function setOptions(string memory _options) public onlyDeployer {\n        options = _options;\n    }\n\n    /// @notice returns either a options object an IPFS location\n    function getOptions() external view returns (string memory) {\n        return options;\n    }\n\n    /// @notice Allows this contract to be linked to a token by the InfinityLinker\n    function getIntegrity()\n        public\n        view\n        override\n        returns (\n            address,\n            address,\n            uint256,\n            bytes memory,\n            bytes4\n        )\n    {\n        return (\n            address(this),\n            deployer,\n            tokenId,\n            'new',\n            type(IntegrityInterface).interfaceId\n        );\n    }\n\n    function request(\n        uint256 pps, //price per second (amount of tokens) the ad payer is willing to pay per second\n        uint256 duration, //the duration of the ad (in seconds)\n        bool utility, //if it is a utility sticker or not,\n        bytes memory requestData\n    ) public payable {\n        require(utility == false || pps == 0, 'pps must be zero if untility');\n\n        require(\n            hasSetup,\n            'deployer has not set up this stickers contract successfully'\n        );\n\n        StickerOracle.RegistrationObject memory obj = stickerOracle\n            .findRegistration(_sender());\n        require(\n            obj.valid == true,\n            'please register with sticker oracle first with the current address'\n        );\n\n        require(\n            utility || stickerOracle.canAfford(pps, duration, _sender()),\n            'cannot afford the PPS you have set for that duration currently'\n        );\n    }\n\n    function getStickerCount() external view returns (uint256) {\n        return stickerId;\n    }\n\n    function getActiveStickers()\n        external\n        view\n        returns (uint256[] memory results)\n    {\n        uint256 count = 0;\n        for (uint256 i = 0; i < stickerId; ) {\n            if (stickers[i].valid && stickers[i].active) count++;\n            unchecked {\n                ++i;\n            }\n        }\n\n        results = new uint256[](count);\n        count = 0;\n        for (uint256 i = 0; i < stickerId; ) {\n            if (stickers[i].valid && stickers[i].active) results[count++] = i;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function getSticker(uint256 _stickerId)\n        external\n        view\n        returns (Sticker memory sticker)\n    {\n        sticker = stickers[_stickerId];\n        require(sticker.valid == true);\n    }\n\n    function setup() public onlyDeployer {\n        require(hasSetup == false, 'has already set up');\n\n        if (stickerOracle.verifyRegistration(tokenId, address(this))) {\n            hasSetup = true;\n            return;\n        }\n\n        //Will throw\n        stickerOracle.registerDeploymentWithOracle(tokenId, address(this));\n        hasSetup = true;\n    }\n}\n"
    },
    "contracts/random/SeededRandom.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n//SafeMath Contract\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\nimport '../RandomNumber.sol';\n\n/// @title InfinityMint Seeded Random\n/// @author 0xTinman.eth\n/// @notice Produces the same randomisation results based on a seed number\n/// @dev NOTE: DO NOT USE THIS OUTSIDE OF PRODUCTION AS PEOPLE CAN CLONE OLD BLOCKS AND THEN WORK OUT THE MINNTS\ncontract SeededRandom is RandomNumber {\n    uint256 internal numberSeed = 12456789;\n\n    constructor(uint32 seedNumber, address valuesContract)\n        RandomNumber(valuesContract)\n    {\n        numberSeed = seedNumber;\n    }\n\n    function returnNumber(uint256 maxNumber, uint256 _salt)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (maxNumber <= 0) maxNumber = 1;\n        uint256 c = uint256(\n            keccak256(\n                abi.encode(\n                    numberSeed,\n                    _salt,\n                    maxNumber,\n                    msg.sender, //is this contract or who ever calls this\n                    randomnessFactor\n                )\n            )\n        );\n\n        (bool safe, uint256 result) = SafeMath.tryMod(c, maxNumber);\n\n        if (safe) return result;\n\n        return 0;\n    }\n}\n"
    },
    "contracts/random/UnsafeRandom.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n//SafeMath Contract\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\nimport '../RandomNumber.sol';\n\ncontract UnsafeRandom is RandomNumber {\n    uint256 internal numberSeed = 12456789;\n\n    constructor(uint32 seedNumber, address valuesContract)\n        RandomNumber(valuesContract)\n    {\n        numberSeed = seedNumber;\n    }\n\n    function returnNumber(uint256 maxNumber, uint256 _salt)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (maxNumber <= 0) maxNumber = 1;\n        uint256 c = uint256(\n            keccak256(\n                abi.encode(\n                    numberSeed,\n                    _salt,\n                    maxNumber,\n                    block.difficulty,\n                    block.number,\n                    block.timestamp,\n                    msg.sender, //is this contract or who ever calls this\n                    randomnessFactor\n                )\n            )\n        );\n\n        (bool safe, uint256 result) = SafeMath.tryMod(c, maxNumber);\n\n        if (safe) return result;\n\n        return 0;\n    }\n}\n"
    },
    "contracts/RandomNumber.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './InfinityMintValues.sol';\n\n/// @title InfinityMint Random Number Abstract Contract\n/// @author 0xTinman.eth\nabstract contract RandomNumber {\n    uint256 public randomnessFactor;\n    bool public hasDeployed = false;\n    uint256 public salt = 1;\n\n    InfinityMintValues internal valuesController;\n\n    constructor(address valuesContract) {\n        valuesController = InfinityMintValues(valuesContract);\n        randomnessFactor = valuesController.getValue('randomessFactor');\n    }\n\n    function getNumber() external returns (uint256) {\n        unchecked {\n            ++salt;\n        }\n\n        return returnNumber(valuesController.getValue('maxRandomNumber'), salt);\n    }\n\n    function getMaxNumber(uint256 maxNumber) external returns (uint256) {\n        unchecked {\n            ++salt;\n        }\n\n        return returnNumber(maxNumber, salt);\n    }\n\n    /// @notice cheap return number\n    function returnNumber(uint256 maxNumber, uint256 _salt)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        if (maxNumber <= 0) maxNumber = 1;\n        return (_salt + 3) % maxNumber;\n    }\n}\n"
    },
    "contracts/Royalty.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './Authentication.sol';\n\n/// @title InfinityMint Royalty Abstract Contract\n/// @author 0xTinman.eth\nabstract contract Royalty is Authentication {\n    //globals\n    InfinityMintValues internal valuesController;\n    address public erc721Destination;\n\n    //payout values\n    mapping(address => uint256) public values;\n    mapping(uint256 => uint256) public freebies;\n\n    uint256 public tokenPrice;\n    uint256 public originalTokenPrice;\n    uint256 public lastTokenPrice;\n    uint256 public stickerSplit;\n\n    uint8 public constant SPLIT_TYPE_MINT = 0;\n    uint8 public constant SPLIT_TYPE_STICKER = 1;\n\n    uint256 internal remainder;\n\n    event DispensedRoyalty(\n        address indexed sender,\n        uint256 amount,\n        uint256 newTotal\n    );\n\n    constructor(address valuesContract) {\n        valuesController = InfinityMintValues(valuesContract);\n\n        tokenPrice =\n            valuesController.tryGetValue('startingPrice') *\n            valuesController.tryGetValue('baseTokenValue');\n        lastTokenPrice =\n            valuesController.tryGetValue('startingPrice') *\n            valuesController.tryGetValue('baseTokenValue');\n        originalTokenPrice =\n            valuesController.tryGetValue('startingPrice') *\n            valuesController.tryGetValue('baseTokenValue');\n\n        if (valuesController.tryGetValue('stickerSplit') > 100)\n            revert('sticker split is a value over 100');\n        stickerSplit = valuesController.tryGetValue('stickerSplit');\n    }\n\n    function changePrice(uint256 _tokenPrice) public onlyDeployer {\n        lastTokenPrice = tokenPrice;\n        tokenPrice = _tokenPrice;\n    }\n\n    function registerFree(uint256 splitType) public onlyApproved {\n        freebies[splitType]++;\n    }\n\n    function dispenseRoyalty(address addr)\n        public\n        onlyApproved\n        onlyOnce\n        returns (uint256 total)\n    {\n        if (values[addr] <= 0) revert('Invalid or Empty address');\n\n        total = values[addr];\n        values[addr] = 0;\n\n        emit DispensedRoyalty(addr, total, values[addr]);\n    }\n\n    function incrementBalance(uint256 value, uint256 typeOfSplit)\n        external\n        virtual;\n}\n"
    },
    "contracts/royalty/DefaultRoyalty.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport '../Royalty.sol';\n\n/**\n    Needs to only allow the deployer to withdraw/set the price\n */\ncontract DefaultRoyalty is Royalty {\n    mapping(uint256 => uint256) public counter;\n\n    constructor(address valuesContract) Royalty(valuesContract) {}\n\n    function incrementBalance(uint256 value, uint256 splitType)\n        external\n        override\n        onlyApproved\n        onlyOnce\n    {\n        //register as free\n        if (value <= 0) {\n            registerFree(splitType);\n            return;\n        }\n\n        counter[splitType] = counter[splitType] + 1;\n        //just give the deployer the entire value\n        values[deployer] = values[deployer] + value;\n    }\n}\n"
    },
    "contracts/royalty/SplitRoyalty.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\nimport '../Royalty.sol';\n\n/**\n    Needs\n */\ncontract SplitRoyalty is Royalty {\n    mapping(uint256 => uint256) public counter;\n\n    bytes[] private splits;\n\n    constructor(address valuesContract) Royalty(valuesContract) {}\n\n    function addSplit(\n        address addr,\n        uint256 percentage,\n        uint256 splitType\n    ) public onlyDeployer {\n        splits.push(abi.encode(addr, percentage, splitType));\n    }\n\n    function getCount(uint256 splitType) external view returns (uint256) {\n        return counter[splitType];\n    }\n\n    function getSplitCount() external view returns (uint256) {\n        return splits.length;\n    }\n\n    function incrementBalance(uint256 value, uint256 splitType)\n        external\n        override\n        onlyApproved\n        onlyOnce\n    {\n        //register as free\n        if (value <= 0) {\n            registerFree(splitType);\n            return;\n        }\n\n        counter[splitType] = counter[splitType] + 1;\n\n        //if no splits / bad split added just give the deployer the entire value\n        if (\n            splits.length == 0 ||\n            splitType > splits.length ||\n            splitType < 0 ||\n            value < 100 //cannot split correctly\n        ) {\n            values[deployer] = values[deployer] + value;\n            return;\n        }\n\n        bool flag = false;\n        uint256 _value = value;\n        for (uint256 i = 0; i < splits.length; i++) {\n            if (_value < 0) revert('Too many royalty splits');\n\n            address _addr;\n            uint256 percentage;\n            uint256 _splitType;\n            (_addr, percentage, _splitType) = abi.decode(\n                splits[i],\n                (address, uint256, uint256)\n            );\n\n            if (percentage <= 0)\n                revert('Precentage is less than zero or equal to zero');\n\n            if (splitType != _splitType) continue;\n\n            uint256 profit = (value / 100) * percentage;\n\n            if (profit <= 0) revert('Profit is less than or equal zero');\n\n            values[_addr] = values[_addr] + profit;\n            _value = _value - profit;\n            flag = true;\n        }\n\n        require(flag, 'did not increment any profits');\n        //if there are any remaining profits just give them to the dployer\n        if (_value > 0) values[deployer] = values[deployer] + _value;\n    }\n\n    function resetSplits() public onlyDeployer {\n        splits = new bytes[](0);\n    }\n\n    function getSplits(address addr)\n        external\n        view\n        returns (uint256[] memory split)\n    {\n        for (uint256 i = 0; i < splits.length; i++) {\n            (address _addr, uint256 percentage, uint256 splitType) = abi.decode(\n                splits[i],\n                (address, uint256, uint256)\n            );\n\n            if (_addr == addr) split[splitType] = percentage;\n        }\n    }\n}\n"
    },
    "contracts/StickerOracle.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//0xTinman.eth 2021\npragma solidity ^0.8.0;\n\nimport './Authentication.sol';\nimport './ERC721.sol';\nimport './StickerOracle.sol';\n\ncontract StickerOracle is ERC721, Authentication, InfinityMintObject {\n    ERC721 erc721;\n\n    struct StickerDestination {\n        address deployer;\n        address destination;\n        uint256 activeStickers;\n        uint256 completedStickers;\n        uint256 deniedStickers;\n        uint256 timestamp;\n        bool valid;\n    }\n\n    struct RegistrationObject {\n        address owner;\n        uint256 balance;\n        uint256 lockedBalance;\n        bool valid;\n    }\n\n    struct RegistrationMap {\n        address owner;\n        uint256 oracleId;\n        bool valid;\n    }\n\n    event AddressRegistration(\n        address indexed sender,\n        uint256 oracleId,\n        RegistrationObject registraitonObject\n    );\n\n    event DeploymentRegistration(\n        address indexed sender,\n        uint256 tokenId,\n        address indexed stickersDestination,\n        StickerDestination destinationObject\n    );\n\n    mapping(address => bool) validDestinations;\n    mapping(uint256 => StickerDestination) public registeredStickerDestinations;\n    mapping(address => RegistrationMap) public addressRegistrations;\n    mapping(uint256 => RegistrationObject) public registrations;\n\n    //internal\n    mapping(address => mapping(uint256 => uint256)) internal registeredStickers;\n    uint256 internal oracleId;\n\n    modifier onlyApprovedStickerContracts() {\n        require(\n            validDestinations[sender()],\n            'sender is not an approved sticker contract'\n        );\n        _;\n    }\n\n    constructor(\n        string memory tokenName,\n        string memory tokenSymbol,\n        address erc721Destination\n    ) ERC721(tokenName, tokenSymbol) {\n        erc721 = ERC721(erc721Destination);\n    }\n\n    function topup() public payable {\n        require(\n            addressRegistrations[sender()].valid,\n            'already regsitered for this address'\n        );\n\n        registrations[addressRegistrations[sender()].oracleId].balance =\n            registrations[addressRegistrations[sender()].oracleId].balance +\n            value();\n    }\n\n    function canAfford(\n        uint256 pps,\n        uint256 duration,\n        address owner\n    ) external view returns (bool) {\n        require(addressRegistrations[owner].valid, 'invalid owner');\n\n        return\n            registrations[addressRegistrations[sender()].oracleId].balance >=\n            (pps * duration);\n    }\n\n    function register() public payable {\n        require(\n            addressRegistrations[sender()].valid == false,\n            'already registered this address'\n        );\n\n        registrations[oracleId] = RegistrationObject(\n            sender(),\n            value(),\n            0,\n            true\n        );\n        addressRegistrations[sender()] = RegistrationMap(\n            sender(),\n            oracleId,\n            true\n        );\n        emit AddressRegistration(sender(), oracleId, registrations[oracleId]);\n        oracleId = oracleId + 1;\n    }\n\n    function getRegistration(uint256 _oracleId)\n        external\n        view\n        returns (RegistrationObject memory)\n    {\n        require(\n            registrations[oracleId].valid,\n            'invalid registration at this id'\n        );\n        return registrations[_oracleId];\n    }\n\n    function findRegistration(address addr)\n        external\n        view\n        returns (RegistrationObject memory)\n    {\n        require(\n            addressRegistrations[addr].valid,\n            'invalid registration for address'\n        );\n        return registrations[addressRegistrations[addr].oracleId];\n    }\n\n    function registerDeploymentWithOracle(\n        uint256 tokenId,\n        address stickersDestination\n    ) public {\n        require(\n            stickersDestination != address(0x0),\n            'enter a sticker destination'\n        );\n\n        require(\n            erc721.isApprovedOrOwner(sender(), tokenId),\n            'ERC721: not approved'\n        );\n\n        Authentication auth = Authentication(stickersDestination);\n        require(\n            auth.deployer() == sender() || auth.isAuthenticated(sender()),\n            'not approved with stickers destination'\n        );\n\n        require(\n            registeredStickerDestinations[tokenId].valid == false,\n            'already registered'\n        );\n\n        registeredStickerDestinations[tokenId] = StickerDestination(\n            sender(),\n            stickersDestination,\n            0,\n            0,\n            0,\n            block.timestamp,\n            true\n        );\n        validDestinations[stickersDestination] = true;\n\n        emit DeploymentRegistration(\n            sender(),\n            tokenId,\n            stickersDestination,\n            registeredStickerDestinations[tokenId]\n        );\n    }\n\n    function registerSticker(\n        uint256 tokenId,\n        uint256 stickerId,\n        uint256 stickerEnd\n    ) public {\n        require(\n            registeredStickerDestinations[tokenId].valid,\n            'no registry for this tokenId'\n        );\n        require(\n            stickerEnd <= block.timestamp,\n            'end is zero or a time in the past'\n        );\n\n        address dest = registeredStickerDestinations[tokenId].destination;\n\n        require(checkSenderIsAuthenticated(dest));\n        require(isValidSticker(dest, stickerId));\n        require(registeredStickers[dest][stickerId] != 0, 'already registered');\n\n        registeredStickers[dest][stickerId] = stickerEnd;\n    }\n\n    function hasStickerCompleted(address stickerDestination, uint256 stickerId)\n        external\n        view\n        returns (bool)\n    {\n        return\n            registeredStickers[stickerDestination][stickerId] >=\n            block.timestamp;\n    }\n\n    function getStickerRegistration(uint256 tokenId)\n        external\n        view\n        returns (StickerDestination memory dest)\n    {\n        dest = registeredStickerDestinations[tokenId];\n        require(dest.valid, 'invalid sticker destination');\n    }\n\n    function verifyRegistration(uint256 tokenId, address stickersDestination)\n        public\n        view\n        returns (bool)\n    {\n        return\n            registeredStickerDestinations[tokenId].valid &&\n            registeredStickerDestinations[tokenId].destination ==\n            stickersDestination;\n    }\n\n    /// @notice We just want to check if the call went through okay\n    function isValidSticker(address stickerDestination, uint256 stickerId)\n        private\n        view\n        returns (bool)\n    {\n        (bool success, ) = stickerDestination.staticcall(\n            abi.encodeWithSignature('getSticker(uint256)', stickerId)\n        );\n\n        return success;\n    }\n\n    function checkSenderIsAuthenticated(address stickerDestination)\n        private\n        view\n        returns (bool)\n    {\n        (bool success, bytes memory returnData) = stickerDestination.staticcall(\n            abi.encodeWithSignature('isAuthenticated(address)', sender())\n        );\n\n        if (!success) {\n            if (returnData.length == 0) revert('is approved or owner reverted');\n            else\n                assembly {\n                    let returndata_size := mload(returnData)\n                    revert(add(32, returnData), returndata_size)\n                }\n        }\n\n        bool result = abi.decode(returnData, (bool));\n        return result == true;\n    }\n}\n"
    },
    "infinitymint/alpha/Asset.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//llydia cross 2021\npragma solidity ^0.8.0;\n\nimport './RandomNumber.sol';\n\nabstract contract Asset {\n    struct PartialStruct {\n        uint32 pathId;\n        uint32[] assets;\n        uint32[] names;\n        uint32[] colours;\n        bytes mintData;\n    }\n\n    function getColours(\n        uint32 pathId,\n        RandomNumber randomNumberController\n    ) public virtual returns (uint32[] memory result);\n\n    function getNextPath() external view virtual returns (uint32);\n\n    function pickPath(\n        uint32 currentTokenId,\n        RandomNumber randomNumberController\n    ) public virtual returns (PartialStruct memory);\n\n    function isValidPath(uint32 pathId) external view virtual returns (bool);\n\n    function pickPath(\n        uint32 pathId,\n        uint32 currentTokenId,\n        RandomNumber randomNumberController\n    ) public virtual returns (PartialStruct memory);\n\n    function getNames(\n        uint256 nameCount,\n        RandomNumber randomNumberController\n    ) public virtual returns (uint32[] memory results);\n\n    function getRandomAsset(\n        uint32 pathId,\n        RandomNumber randomNumberController\n    ) external virtual returns (uint32[] memory assetsId);\n\n    function getMintData(\n        uint32 pathId,\n        uint32 tokenId,\n        RandomNumber randomNumberController\n    ) public virtual returns (bytes memory);\n\n    function addAsset(uint256 rarity) public virtual;\n\n    function setNextPathId(uint32 pathId) public virtual;\n\n    function setLastPathId(uint32 pathId) public virtual;\n\n    function getPathSize(uint32 pathId) public view virtual returns (uint32);\n\n    function getNextPathId(\n        RandomNumber randomNumberController\n    ) public virtual returns (uint32);\n}\n"
    },
    "infinitymint/alpha/Authentication.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//llydia cross 2021\npragma solidity ^0.8.0;\n\nimport './InfinityMintObject.sol';\n\nabstract contract Authentication {\n    address public deployer;\n    /// @notice for re-entry prevention, keeps track of a methods execution count\n    uint256 private executionCount;\n    uint256 public approvalCount;\n\n    mapping(address => bool) public approved;\n\n    constructor() {\n        deployer = msg.sender;\n        approved[msg.sender] = true;\n        executionCount = 0;\n        approvalCount = 0;\n    }\n\n    event PermissionChange(\n        address indexed sender,\n        address indexed changee,\n        bool value\n    );\n\n    event TransferedOwnership(address indexed from, address indexed to);\n\n    /// @notice Limits execution of a method to once in the given context.\n    /// @dev prevents re-entry attack\n    modifier onlyOnce() {\n        executionCount += 1;\n        uint256 localCounter = executionCount;\n        _;\n        require(localCounter == executionCount, 're-entry');\n    }\n\n    modifier onlyDeployer() {\n        require(deployer == msg.sender, 'not deployer');\n        _;\n    }\n\n    modifier onlyApproved() {\n        require(\n            deployer == msg.sender || approved[msg.sender],\n            string.concat(\n                '0x',\n                toAsciiString(msg.sender),\n                ' not approved on 0x',\n                toAsciiString(address(this))\n            )\n        );\n        _;\n    }\n\n    function setPrivilages(address addr, bool value) public onlyDeployer {\n        require(addr != deployer, 'cannot modify deployer');\n        approved[addr] = value;\n\n        if (value) approvalCount++;\n        else approvalCount--;\n\n        emit PermissionChange(msg.sender, addr, value);\n    }\n\n    function multiApprove(address[] memory addrs) public onlyDeployer {\n        require(addrs.length != 0);\n        for (uint256 i = 0; i < addrs.length; ) {\n            approved[addrs[i]] = true;\n            approvalCount++;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function multiRevoke(address[] memory addrs) public onlyDeployer {\n        require(addrs.length != 0);\n        for (uint256 i = 0; i < addrs.length; ) {\n            approved[addrs[i]] = false;\n            approvalCount--;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function isAuthenticated(address addr) external view returns (bool) {\n        return addr == deployer || approved[addr];\n    }\n\n    function transferOwnership(address addr) public onlyDeployer {\n        approved[deployer] = false;\n        deployer = addr;\n        approved[addr] = true;\n\n        emit TransferedOwnership(msg.sender, addr);\n    }\n\n    //for more detailed output\n    function toAsciiString(address x) internal pure returns (string memory) {\n        bytes memory s = new bytes(40);\n        for (uint i = 0; i < 20; i++) {\n            bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\n            bytes1 hi = bytes1(uint8(b) / 16);\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n            s[2 * i] = char(hi);\n            s[2 * i + 1] = char(lo);\n        }\n        return string(s);\n    }\n\n    //for more detailed output\n    function char(bytes1 b) internal pure returns (bytes1 c) {\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n        else return bytes1(uint8(b) + 0x57);\n    }\n}\n"
    },
    "infinitymint/alpha/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport './IERC165.sol';\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "infinitymint/alpha/ERC721.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//llydia cross 2021\npragma solidity ^0.8.0;\n\nimport './IERC721.sol';\nimport './ERC165.sol';\nimport './IERC165.sol';\n\n/// @title ERC-721 Infinity Mint Implementation\n/// @author Llydia Cross\n/// @notice This is a basic ERC721 Implementation that is designed to be as simple and gas efficient as possible.\n/// @dev This contract supports tokenURI (the Metadata extension) but does not include the Enumerable extension.\ncontract ERC721 is ERC165, IERC721, IERC721Metadata {\n    ///@notice Storage for the tokens\n    ///@dev indexed by tokenId\n    mapping(uint256 => address) internal tokens; //(slot 0)\n    ///@notice Storage the token metadata\n    ///@dev indexed by tokenId\n    mapping(uint256 => string) internal uri; //(slot 1)\n    ///@notice Storage the token metadata\n    ///@dev indexed by tokenId\n    mapping(uint256 => address) internal approvedTokens; //(slot 2)\n    ///@notice Stores approved operators for the addresses tokens.\n    mapping(address => mapping(address => bool)) internal operators; //(slot 3)\n    ///@notice Stores the balance of tokens\n    mapping(address => uint256) internal balance; //(slot 4)\n\n    ///@notice The name of the ERC721\n    string internal _name; //(slot 5)\n    ///@notice The Symbol of the ERC721\n    string internal _symbol; //(slot 6)\n\n    /**\n        @notice ERC721 Constructor takes tokenName and tokenSymbol\n     */\n    constructor(string memory tokenName, string memory tokenSymbol) {\n        _name = tokenName;\n        _symbol = tokenSymbol;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     * @notice this is used by opensea/polyscan to detect our ERC721\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n        @notice blanceOf returns the number of tokens an address currently holds.\n     */\n    function balanceOf(address _owner) public view override returns (uint256) {\n        return balance[_owner];\n    }\n\n    /**\n        @notice Returns the owner of a current token\n        @dev will Throw if the token does not exist\n     */\n    function ownerOf(uint256 _tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        require(exists(_tokenId), 'invalid tokenId');\n        return tokens[_tokenId];\n    }\n\n    /**\n        @notice Will approve an operator for the senders tokens\n    */\n    function setApprovalForAll(address _operator, bool _approved)\n        public\n        override\n    {\n        operators[_sender()][_operator] = _approved;\n        emit ApprovalForAll(_sender(), _operator, _approved);\n    }\n\n    /**\n        @notice Will returns true if the operator is approved by the owner address\n    */\n    function isApprovedForAll(address _owner, address _operator)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return operators[_owner][_operator];\n    }\n\n    /**\n        @notice Returns the tokens URI Metadata object\n    */\n    function tokenURI(uint256 _tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        return uri[_tokenId];\n    }\n\n    /**\n        @notice Returns the name of the ERC721  for display on places like Etherscan\n    */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n        @notice Returns the symbol of the ERC721 for display on places like Polyscan\n    */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n        @notice Returns the approved adress for this token.\n    */\n    function getApproved(uint256 _tokenId)\n        public\n        view\n        override\n        returns (address)\n    {\n        return approvedTokens[_tokenId];\n    }\n\n    /**\n        @notice Sets an approved adress for this token\n        @dev will Throw if tokenId does not exist\n    */\n    function approve(address _to, uint256 _tokenId) public override {\n        address owner = ERC721.ownerOf(_tokenId);\n\n        require(_to != owner, 'cannot approve owner');\n        require(\n            _sender() == owner || isApprovedForAll(owner, _sender()),\n            'ERC721: approve caller is not token owner or approved for all'\n        );\n        approvedTokens[_tokenId] = _to;\n        emit Approval(owner, _to, _tokenId);\n    }\n\n    /**\n        @notice Mints a token.\n        @dev If you are transfering a token to a contract the contract will make sure that it can recieved the ERC721 (implements a IERC721Receiver) if it does not it will revert the transcation. Emits a {Transfer} event.\n    */\n    function mint(\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) internal {\n        require(_to != address(0x0), '0x0 mint');\n        require(!exists(_tokenId), 'already minted');\n\n        balance[_to] += 1;\n        tokens[_tokenId] = _to;\n\n        emit Transfer(address(0x0), _to, _tokenId);\n\n        //check that the ERC721 has been received\n        require(\n            checkERC721Received(_sender(), address(this), _to, _tokenId, _data)\n        );\n    }\n\n    /**\n        @notice Returns true if a token exists.\n     */\n    function exists(uint256 _tokenId) public view returns (bool) {\n        return tokens[_tokenId] != address(0x0);\n    }\n\n    /// @notice Is ran before every transfer, overwrite this function with your own logic\n    /// @dev Must return true else will revert\n    function beforeTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual {}\n\n    /**\n        @notice Transfers a token fsrom one address to another. Use safeTransferFrom as that will double check that the address you send this token too is a contract that can actually receive it.\n\t\t@dev Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) public virtual override {\n        require(\n            isApprovedOrOwner(_sender(), _tokenId),\n            'not approved or owner'\n        );\n        require(_from != address(0x0), 'sending to null address');\n\n        //before the transfer\n        beforeTransfer(_from, _to, _tokenId);\n\n        delete approvedTokens[_tokenId];\n        balance[_from] -= 1;\n        balance[_to] += 1;\n        tokens[_tokenId] = _to;\n\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /// @notice will returns true if the address is apprroved for all, approved operator or is the owner of a token\n    /// @dev same as open zepps\n    function isApprovedOrOwner(address addr, uint256 tokenId)\n        public\n        view\n        returns (bool)\n    {\n        address owner = ERC721.ownerOf(tokenId);\n        return (addr == owner ||\n            isApprovedForAll(owner, addr) ||\n            getApproved(tokenId) == addr);\n    }\n\n    /**\n        @notice Just like transferFrom except we will check if the to address is a contract and is an IERC721Receiver implementer\n\t\t@dev Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) public virtual override {\n        _safeTransferFrom(_from, _to, _tokenId, _data);\n    }\n\n    /**\n        @notice Just like the method above except with no data field we pass to the implemeting contract.\n\t\t@dev Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) public virtual override {\n        _safeTransferFrom(_from, _to, _tokenId, '');\n    }\n\n    /**\n        @notice Internal method to transfer the token and require that checkERC721Recieved is equal to true.\n     */\n    function _safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) private {\n        transferFrom(_from, _to, _tokenId);\n        //check that it implements an IERC721 receiver if it is a contract\n        require(\n            checkERC721Received(_sender(), _from, _to, _tokenId, _data),\n            'ERC721 Receiver Confirmation Is Bad'\n        );\n    }\n\n    /**\n        @notice Checks first if the to address is a contract, if it is it will confirm that the contract is an ERC721 implentor by confirming the selector returned as documented in the ERC721 standard. If the to address isnt a contract it will just return true. Based on the code inside of OpenZeppelins ERC721\n     */\n    function checkERC721Received(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (!isContract(_to)) return true;\n\n        try\n            IERC721Receiver(_to).onERC721Received(\n                _operator,\n                _from,\n                _tokenId,\n                _data\n            )\n        returns (bytes4 confirmation) {\n            return (confirmation == IERC721Receiver.onERC721Received.selector);\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert('This contract does not implement an IERC721Receiver');\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }\n\n    ///@notice secures msg.sender so it cannot be changed\n    function _sender() internal view returns (address) {\n        return (msg.sender);\n    }\n\n    ///@notice Returns true if the address is a contract\n    ///@dev Sometimes doesnt work and contracts might be disgused as addresses\n    function isContract(address _address) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(_address)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "infinitymint/alpha/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "infinitymint/alpha/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol) (Thanks <3)\n\npragma solidity ^0.8.0;\n\nimport './IERC165.sol';\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, ERC721 Receiver\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface IERC721Metadata is IERC721 {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string memory _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string memory _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n"
    },
    "infinitymint/alpha/InfinityMint.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//llydia cross 2021\npragma solidity ^0.8.0;\n\n//\nimport './ERC721.sol';\nimport './InfinityMintStorage.sol';\nimport './Royalty.sol';\nimport './Authentication.sol';\nimport './Minter.sol';\nimport './InfinityMintObject.sol';\n\n/// @title InfinityMint ERC721 Implementation\n/// @author Llydia Cross\n/// @notice\n/// @dev\ncontract InfinityMint is ERC721, Authentication, InfinityMintObject {\n    /// @notice Interface set to the location of the storage controller, is set in constructor and cannot be modified.\n    InfinityMintStorage public storageController;\n\n    /// @notice Interface set to the location of the minter controller which controls how InfinityMint mints, is set in constructor and can be modified through setDestinations\n    Minter public minterController;\n\n    /// @notice Interface set to the location of the values controller responsible for managing global variables across the smart contract syste,, is set in constructor and cannot be modified.\n    InfinityMintValues public valuesController;\n\n    /// @notice Interface set to the location of the royalty controller which controls how  picks random numbers and primes, is set in constructor and can be modified through setDestinations\n    Royalty public royaltyController;\n\n    /// @dev will be changed to TokenMinted soon\n    event TokenMinted(uint32 tokenId, address indexed sender);\n\n    /// @dev will be changed to TokenPreviewMinted soon\n    event TokenPreviewMinted(uint32 tokenId, address indexed sender);\n\n    /// @notice Fired when ever a preview has been completed\n    event TokenPreviewComplete(address indexed sender, uint256 previewCount);\n\n    /// @notice numerical increment of the current tokenId\n    uint32 public currentTokenId;\n\n    /// @notice will disallow mints if set to true\n    bool public mintsEnabled;\n\n    /// @notice InfinityMint Constructor takes tokenName and tokenSymbol and the various destinations of controller contracts\n    constructor(\n        string memory tokenName,\n        string memory tokenSymbol,\n        address storageContract,\n        address valuesContract,\n        address minterContract,\n        address royaltyContract\n    ) ERC721(tokenName, tokenSymbol) {\n        //storage controller cannot be rewired\n        storageController = InfinityMintStorage(storageContract); //address of the storage controlller\n        //values controller cannot be rewired\n        valuesController = InfinityMintValues(valuesContract);\n        //\n        royaltyController = Royalty(royaltyContract);\n        minterController = Minter(minterContract);\n    }\n\n    ///@notice Sets the destinations of the storage contract\n    ///@dev Contracts must inherit the the same interfaces this contract has been built with, so version 1 Omega stuff.\n    function setStorageController(address storageContract) public onlyApproved {\n        require(storageContract != address(0x0));\n        storageController = InfinityMintStorage(storageContract);\n    }\n\n    ///@notice Sets the destinations of the minter contract\n    ///@dev Contracts must inherit the the same interfaces this contract has been built with, so version 1 Omega stuff.\n    function setMinterController(address minterContract) public onlyApproved {\n        require(minterContract != address(0x0));\n        minterController = Minter(minterContract);\n    }\n\n    ///@notice Sets the destinations of the royalty contract\n    ///@dev Contracts must inherit the the same interfaces this contract has been built with, so version 1 Omega stuff.\n    function setRoyaltyController(address royaltyContract) public onlyDeployer {\n        require(royaltyContract != address(0x0));\n        royaltyController = Royalty(royaltyContract);\n    }\n\n    /// @notice the total supply of tokens\n    /// @dev Returns the max supply of tokens, not the amount that have been minted. (so the tokenId)\n    function totalSupply() public view returns (uint256) {\n        return valuesController.tryGetValue('maxSupply');\n    }\n\n    /// @notice Toggles mints allowing people to either mint or not mint tokens.\n    function setMintsEnabled(bool value) public onlyApproved {\n        mintsEnabled = value;\n    }\n\n    /// @notice Gets the pathId of a token.\n    function getPathId(uint32 tokenId) external view returns (uint256) {\n        return storageController.get(tokenId).pathId;\n    }\n\n    /// @notice Returns a selection of preview mints, these are ghost NFTs which can be chosen from. Their generation values are based off of eachover due to the nature of the number system.\n    /// @dev This method is the most gas intensive method in InfinityMint, how ever there is a trade off in the fact that that MintPreview is insanely cheap and does not need a lot of gas. I suggest using low previewCount values of about 2 or 3. Anything higher is dependant in your project configuartion and how much you care about gas prices.\n    function getPreview() public {\n        require(\n            veriyMint(0, false),\n            'failed mint check: mints are disabled, mints are at a max supply'\n        ); //does not check the price\n\n        //if the user has already had their daily preview mints\n        require(\n            valuesController.tryGetValue('previewCount') > 0,\n            'previews are disabled'\n        );\n\n        //the preview timer will default to zero unless a preview has already been minted so there for it can be used like a check\n        require(\n            block.timestamp > storageController.getPreviewTimestamp(sender()),\n            'please mint previews or wait until preview counter is up'\n        );\n\n        //minter controller will store the previews for us\n        uint256 previewCount = minterController.getPreview(\n            currentTokenId,\n            sender()\n        );\n\n        //get cooldown of previews\n        uint256 cooldownPeriod = valuesController.tryGetValue(\n            'previewCooldownSeconds'\n        );\n        //if it is 0 (not set), set to 60 seconds\n        if (cooldownPeriod == 0) cooldownPeriod = 60;\n        //set it\n        storageController.setPreviewTimestamp(\n            sender(),\n            block.timestamp + cooldownPeriod\n        );\n\n        //once done, emit an event\n        emit TokenPreviewComplete(sender(), previewCount);\n    }\n\n    /// @notice Mints a preview. Index is relative to the sender and is the index of the preview in the users preview list\n    /// @dev This will wipe other previews once called.\n    /// @param index the index of the preview to mint\n    function mintPreview(uint32 index) public payable onlyOnce {\n        uint256 value = (msg.value);\n        require(\n            veriyMint(value, !approved[sender()]),\n            'failed mint verification'\n        ); //will not check the price for approved members\n\n        completeMint(\n            minterController.mintPreview(index, currentTokenId, sender()),\n            sender(),\n            true,\n            value,\n            true\n        );\n    }\n\n    /// @notice Allows you to mint multiple tokens at once\n    /// @dev This is the cheapest way to get InfinityMint to mint something as it literally decides no values on chain. This method can also be called by a rollup solution or something or be used as a way to literally mint anything,\n    /// @param pathId an array of path ids you would like to mint\n    /// @param colours an array of colours you would like to mint\n    /// @param mintData an array of mintdata  you would like to mint\n    /// @param assets an array of assets you would like to mint\n    /// @param names an array of names you would like to mint\n    function implicitBatch(\n        uint32[] memory pathId,\n        uint32[][] memory colours,\n        bytes[] memory mintData,\n        uint32[][] memory assets,\n        uint32[][] memory names\n    ) public onlyApproved {\n        require(\n            colours.length == pathId.length &&\n                mintData.length == pathId.length &&\n                assets.length == pathId.length &&\n                names.length == pathId.length,\n            'all argument lengths must match'\n        );\n\n        //Note: Not using the implicitBatch method as it emits events, this will not\n        for (uint256 i = 0; i < pathId.length; i++) {\n            //check max supply\n            require(\n                currentTokenId + i != valuesController.tryGetValue('maxSupply'),\n                'max supply has been reached raise it before minting'\n            );\n\n            completeMint(\n                create(\n                    currentTokenId,\n                    pathId[i],\n                    assets[i],\n                    names[i],\n                    colours[i],\n                    mintData[i],\n                    sender(),\n                    new address[](0)\n                ),\n                sender(),\n                false,\n                value(),\n                false //dont emit event\n            );\n\n            currentTokenId += 1;\n        }\n\n        if (valuesController.isTrue('incrementalMode'))\n            minterController.assetController().setLastPathId(\n                pathId[pathId.length - 1] + 1\n            );\n    }\n\n    /// @notice Allows approved or the deployer to pick exactly what token they would like to mint. Does not check if assets/colours/mintData is valid. Implicitly assets what ever.\n    /// @dev This is the cheapest way to get InfinityMint to mint something as it literally decides no values on chain. This method can also be called by a rollup solution or something or be used as a way to literally mint anything.\n    /// @param receiver the address to receive the mint\n    /// @param pathId the pathid you want to mint\n    /// @param colours the colours of this token\n    /// @param assets the assets for this token\n    function implicitMint(\n        address receiver,\n        uint32 pathId,\n        uint32[] memory colours,\n        bytes memory mintData,\n        uint32[] memory assets,\n        uint32[] memory names\n    ) public onlyApproved {\n        require(\n            currentTokenId != valuesController.tryGetValue('maxSupply'),\n            'max supply has been reached raise it before minting'\n        );\n\n        //if we are incremental mode we want to set the last path id (which is actually the next one) to be plus one of the current\n        //path id in case an on chain mint occurs\n        if (valuesController.isTrue('incrementalMode'))\n            minterController.assetController().setLastPathId(pathId + 1);\n\n        completeMint(\n            create(\n                currentTokenId,\n                pathId,\n                assets,\n                names,\n                colours,\n                mintData,\n                receiver,\n                new address[](0)\n            ),\n            receiver,\n            false,\n            value(),\n            true\n        );\n    }\n\n    /// @notice Returns the current price of a mint.\n    /// @dev the royalty controller actually controls the token price so in order to change it you must send tx to that contract.\n    function tokenPrice() public view returns (uint256) {\n        return royaltyController.tokenPrice();\n    }\n\n    /// @notice Public method to mint a token but taking input data in the form of packed bytes\n    /// @dev must have byteMint enabled in valuesController\n    function mintArguments(bytes memory data) public payable onlyOnce {\n        require(\n            valuesController.isTrue('disableMintArguments'),\n            'mint arguments are disabled'\n        );\n        require(data.length != 0, 'length of bytes is zero');\n\n        _mint(data);\n    }\n\n    /// @notice Public method to mint a token taking no bytes argument\n    function mint() public payable onlyOnce {\n        require(\n            !valuesController.isTrue('byteMint'),\n            'must mint with byteMint instead of mint'\n        );\n\n        _mint(bytes(''));\n    }\n\n    /// @notice returns the tokenURI for a token, will return the\n    function tokenURI(\n        uint256 tokenId\n    ) public view override returns (string memory result) {\n        require(tokenId < currentTokenId, 'tokenURI for non-existent token');\n\n        result = 'https://bafybeihxmdkmvvjksktowehyvwqh62bwnv4vja6llbl7kbzvbrgee5aimu.ipfs.w3s.link/default_uri.json'; //our default\n        string memory defaultTokenURI = storageController.getOption(\n            address(this),\n            'defaultTokenURI'\n        ); //NOTE: assuming this is JSON or URI is http address...\n        //This must have in it somewhere the key \"default\": true else the react applicaton will think that this is an actual tokenURI\n\n        if (bytes(defaultTokenURI).length != 0) result = defaultTokenURI;\n\n        address owner = ownerOf(tokenId);\n        string memory currentTokenURI = uri[tokenId];\n\n        if (\n            storageController.tokenFlag(uint32(tokenId), 'forceTokenURI') &&\n            bytes(currentTokenURI).length != 0\n        ) result = currentTokenURI;\n        else if (\n            storageController.flag(owner, 'usingRoot') ||\n            storageController.flag(address(this), 'usingRoot')\n        ) {\n            //if the owner of the token is using the root, then return the address of the owner, if the project is using a root, return this current address\n            address selector = storageController.flag(owner, 'usingRoot')\n                ? owner\n                : address(this);\n            //gets the root of the tokenURI destination, could be anything, HTTP link or more.\n            string memory root = storageController.getOption(selector, 'root');\n            //the preix to add to the end or the stitch, by default .json will be added unless the boolean inside of the\n            //values controller called \"removeDefaultSuffix\" is true.\n            string memory rootSuffix = storageController.getOption(\n                selector,\n                'rootSuffix'\n            );\n            if (\n                bytes(rootSuffix).length == 0 &&\n                !valuesController.isTrue('removeDefaultSuffix')\n            ) rootSuffix = '.json';\n\n            if (bytes(root).length != 0)\n                result = string.concat(\n                    root,\n                    InfinityMintUtil.toString(tokenId),\n                    rootSuffix\n                );\n        } else if (bytes(currentTokenURI).length != 0) result = currentTokenURI;\n    }\n\n    /// @notice Allows you to withdraw your earnings from the contract.\n    /// @dev The totals that the sender can withdraw is managed by the royalty controller\n    function withdraw() public onlyOnce {\n        uint256 total = royaltyController.values(sender());\n        require(total > 0, 'no balance to withdraw');\n        require(\n            address(this).balance - total >= 0,\n            'cannot afford to withdraw'\n        );\n\n        total = royaltyController.dispenseRoyalty(sender()); //will revert if bad, results in the value to be deposited. Has Re-entry protection.\n        require(total > 0, 'value returned from royalty controller is bad');\n\n        (bool success, ) = sender().call{ value: total }('');\n        require(success, 'did not transfer successfully');\n    }\n\n    /// @notice this can only be called by sticker contracts and is used to pay back the contract owner their sticker cut TODO: Turn this into a non static function capable of accepting payments not just from the sticker\n    /// @dev the amount that is paid into this function is defined by the sticker price set by the token owner. The royalty controller cuts up the deposited tokens even more depending on if there are any splits.\n    function depositStickerRoyalty(uint32 tokenId) public payable onlyOnce {\n        InfinityObject memory temp = storageController.get(tokenId);\n        //if the sender isn't the sticker contract attached to this token\n        require(\n            storageController.validDestination(tokenId, 1),\n            'sticker contract not set'\n        );\n        require(\n            sender() == temp.destinations[1],\n            'Sender must be the sticker contract attached to this token'\n        );\n\n        //increment\n        royaltyController.incrementBalance(\n            value(),\n            royaltyController.SPLIT_TYPE_STICKER()\n        );\n    }\n\n    /// @notice Allows approved contracts to deposit royalty types\n    function depositSystemRoyalty(\n        uint32 royaltyType\n    ) public payable onlyOnce onlyApproved {\n        require(value() >= 0, 'not allowed to deposit zero values');\n        require(\n            royaltyType != royaltyController.SPLIT_TYPE_STICKER(),\n            \"can't deposit sticker royalties here\"\n        );\n\n        //increment\n        royaltyController.incrementBalance(value(), royaltyType);\n        //dont revert allow deposit\n    }\n\n    /// @notice Allows the ability for multiple tokens to be transfered at once.\n    /// @dev must be split up into chunks of 32\n    function transferBatch(\n        uint256[] memory tokenIds,\n        address destination\n    ) public {\n        require(tokenIds.length < 32, 'please split up into chunks of 32');\n        for (uint256 i = 0; i < tokenIds.length; ) {\n            safeTransferFrom(sender(), destination, tokenIds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice See {ERC721}\n    function beforeTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        require(\n            storageController.tokenFlag(uint32(tokenId), 'locked') != true,\n            'This token is locked and needs to be unlocked before it can be transfered'\n        );\n\n        //transfer it in storage\n        storageController.transfer(to, uint32(tokenId));\n\n        if (!valuesController.isTrue('disableRegisteredTokens')) {\n            storageController.addToRegisteredTokens(to, uint32(tokenId));\n\n            if (from != address(0x0))\n                storageController.deleteFromRegisteredTokens(\n                    from,\n                    uint32(tokenId)\n                );\n        }\n    }\n\n    /// @notice sets the token URI\n    /// @dev you need to call this from an approved address for the token\n    /// @param tokenId the tokenId\n    /// @param json an IFPS link or a\n    function setTokenURI(uint32 tokenId, string memory json) public {\n        require(\n            isApprovedOrOwner(sender(), tokenId),\n            'is not Owner, approved or approved for all'\n        );\n        uri[tokenId] = json;\n    }\n\n    /// @notice Mints a token and stores its data inside of the storage contract, increments royalty totals and emits event.\n    /// @dev This is called after preview mint, implicit mint and normal mints to finish up the transaction. We also wipe previous previews the address might have secretly inside the storageController.set method.\n    /// @param data the InfinityMint token data,\n    /// @param mintReceiver the sender or what should be tx.origin address\n    /// @param isPreviewMint is true if the mint was from a preview\n    /// @param mintPrice the value of the msg\n    function completeMint(\n        InfinityMintObject.InfinityObject memory data,\n        address mintReceiver,\n        bool isPreviewMint,\n        uint256 mintPrice,\n        bool shouldEmit\n    ) private {\n        //mint it\n        ERC721.mint(mintReceiver, currentTokenId, data.mintData);\n        //store it, also registers it for look up + deletes previous previews\n        storageController.set(currentTokenId, data);\n\n        //added for fast on chain look up on ganache basically, in a live environment registeredTokens should be disabled\n        if (!valuesController.isTrue('disableRegisteredTokens'))\n            storageController.addToRegisteredTokens(\n                mintReceiver,\n                currentTokenId\n            );\n\n        //increment balance inside of royalty controller\n        royaltyController.incrementBalance(\n            mintPrice,\n            royaltyController.SPLIT_TYPE_MINT()\n        );\n\n        if (!shouldEmit) return;\n        if (isPreviewMint) {\n            //if true then its a preview mint\n            emit TokenPreviewMinted(currentTokenId++, mintReceiver);\n            return;\n        }\n\n        emit TokenMinted(currentTokenId++, mintReceiver);\n    }\n\n    /// @notice Mints a new ERC721 InfinityMint Token\n    /// @dev Takes no arguments. You dont have to pay for the mint if you are approved (or the deployer)\n    function _mint(bytes memory data) private {\n        //check if mint is valid\n        require(\n            veriyMint(value(), !approved[sender()]),\n            'failed mint check: mints are disabled, mints are at a max supply or you did not pay enough'\n        );\n        completeMint(\n            minterController.mint(currentTokenId, sender(), data),\n            sender(),\n            false,\n            value(),\n            true\n        );\n    }\n\n    /// @notice checks the transaction to see if it is valid\n    /// @dev checks if the price is the current token price and if mints are disabled and if the maxSupply hasnt been met\n    /// @param mintPrice the value of the current message\n    /// @param checkPrice if we should check the current price\n    function veriyMint(\n        uint256 mintPrice,\n        bool checkPrice\n    ) private view returns (bool) {\n        if (\n            !mintsEnabled ||\n            currentTokenId >= valuesController.tryGetValue('maxSupply') ||\n            (checkPrice && mintPrice != royaltyController.tokenPrice())\n        ) return false;\n\n        return true;\n    }\n}\n"
    },
    "infinitymint/alpha/InfinityMintApi.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//llydia cross 2021\npragma solidity ^0.8.0;\n\nimport './InfinityMint.sol';\nimport './Asset.sol';\nimport './InfinityMintValues.sol';\nimport './Royalty.sol';\nimport './InfinityMintProject.sol';\n\n/// @title InfinityMint API\n/// @author Llydia Cross\n/// @notice The purpose of this contract is to act as a service to provide data in a web3 or web2 context. You will find methods for data retrival here for previews, tokens, and stickers. and it is advised that you use get from here and not actual storage contract!\n/// @dev\ncontract InfinityMintApi is InfinityMintObject {\n    InfinityMint public erc721;\n    InfinityMintStorage public storageController;\n    Asset public assetController;\n    InfinityMintValues public valuesController;\n    Royalty public royaltyController;\n    InfinityMintProject public projectController;\n\n    constructor(\n        address erc721Destination,\n        address storageDestination,\n        address assetDestination,\n        address valuesDestination,\n        address royaltyDestination,\n        address projectDestination\n    ) {\n        erc721 = InfinityMint(erc721Destination);\n        storageController = InfinityMintStorage(storageDestination);\n        assetController = Asset(assetDestination);\n        valuesController = InfinityMintValues(valuesDestination);\n        royaltyController = Royalty(royaltyDestination);\n        projectController = InfinityMintProject(projectDestination);\n    }\n\n    function getPrice() external view returns (uint256) {\n        return royaltyController.tokenPrice();\n    }\n\n    function getCurrentProject()\n        external\n        view\n        returns (\n            bytes memory encodedUrl,\n            bytes memory encodedTag,\n            uint256 version\n        )\n    {\n        return (\n            projectController.getProject(),\n            projectController.getCurrentTag(),\n            projectController.getCurrentVersion()\n        );\n    }\n\n    function getProject(\n        uint256 version\n    )\n        external\n        view\n        returns (\n            bytes memory encodedProject,\n            bytes memory encodedTag,\n            bytes memory encodedInitialProject\n        )\n    {\n        return projectController.getVersion(version);\n    }\n\n    function isPreviewBlocked(address sender) external view returns (bool) {\n        //returns true only if the current time stamp is less than the preview timestamp\n        return block.timestamp < storageController.getPreviewTimestamp(sender);\n    }\n\n    /// @notice only returns a maximum of 256 tokens use offchain retrival services to obtain token information on owner!\n    function allTokens(\n        address owner\n    ) public view returns (uint32[] memory tokens) {\n        require(\n            !valuesController.isTrue('disableRegisteredTokens'),\n            'all tokens method is disabled'\n        );\n\n        return storageController.getAllRegisteredTokens(owner);\n    }\n\n    function getBytes(uint32 tokenId) external view returns (bytes memory) {\n        if (tokenId < 0 || tokenId >= erc721.currentTokenId()) revert();\n\n        InfinityObject memory data = storageController.get(tokenId);\n\n        return encode(data);\n    }\n\n    /// @notice gets the balance of a wallet associated with a tokenId\n    function getBalanceOfWallet(uint32 tokenId) public view returns (uint256) {\n        address addr = getLink(tokenId, 0);\n        if (addr == address(0x0)) return 0;\n        (bool success, bytes memory returnData) = addr.staticcall(\n            abi.encodeWithSignature('getBalance')\n        );\n\n        if (!success) return 0;\n\n        return abi.decode(returnData, (uint256));\n    }\n\n    function setOption(string memory key, string memory option) external {\n        require(erc721.balanceOf(sender()) > 0, 'must own at least one token');\n        storageController.setOption(sender(), key, option);\n    }\n\n    function setTokenFlag(\n        uint32 tokenId,\n        string memory key,\n        bool value\n    ) external {\n        require(\n            erc721.isApprovedOrOwner(sender(), tokenId),\n            'must be owner or approved'\n        );\n        storageController.setTokenFlag(tokenId, key, value);\n    }\n\n    function setFlag(string memory key, bool value) external {\n        require(erc721.balanceOf(sender()) > 0, 'must own at least one token');\n        storageController.setFlag(sender(), key, value);\n    }\n\n    function get(uint32 tokenId) external view returns (InfinityObject memory) {\n        return storageController.get(tokenId);\n    }\n\n    function getWalletContract(uint32 tokenId) public view returns (address) {\n        return\n            getLink(tokenId, valuesController.tryGetValue('linkWalletIndex'));\n    }\n\n    function getLink(\n        uint32 tokenId,\n        uint256 index\n    ) public view returns (address) {\n        if (tokenId > storageController.get(tokenId).destinations.length)\n            return address(0x0);\n\n        return storageController.get(tokenId).destinations[index];\n    }\n\n    function getStickerContract(uint32 tokenId) public view returns (address) {\n        return\n            getLink(tokenId, valuesController.tryGetValue('linkStickersIndex'));\n    }\n\n    function getPreviewTimestamp(address addr) public view returns (uint256) {\n        return storageController.getPreviewTimestamp(addr);\n    }\n\n    function getPreviewCount(address addr) public view returns (uint256 count) {\n        //find previews\n        InfinityMintObject.InfinityObject[] memory previews = storageController\n            .findPreviews(addr, valuesController.tryGetValue('previewCount'));\n\n        //since mappings initialize their values at defaults we need to check if we are owner\n        count = 0;\n        for (uint256 i = 0; i < previews.length; ) {\n            if (previews[i].owner == addr) count++;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function getPreviews(address addr) external view returns (uint32[] memory) {\n        require(addr != address(0x0), 'cannot view previews for null address');\n\n        //find previews\n        InfinityMintObject.InfinityObject[] memory previews = storageController\n            .findPreviews(addr, valuesController.tryGetValue('previewCount'));\n\n        //since mappings initialize their values at defaults we need to check if we are owner\n        uint256 count = 0;\n        for (uint256 i = 0; i < previews.length; ) {\n            if (previews[i].owner == addr) count++;\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (count > 0) {\n            uint32[] memory rPreviews = new uint32[](count);\n            count = 0;\n            for (uint256 i = 0; i < previews.length; ) {\n                rPreviews[count++] = uint32(i);\n                unchecked {\n                    ++i;\n                }\n            }\n\n            return rPreviews;\n        }\n\n        return new uint32[](0);\n    }\n\n    function getPreview(\n        uint32 index\n    ) public view returns (InfinityObject memory) {\n        return storageController.getPreviewAt(sender(), index);\n    }\n\n    function totalMints() external view returns (uint32) {\n        return erc721.currentTokenId();\n    }\n\n    //the total amount of tokens\n    function totalSupply() external view returns (uint256) {\n        return valuesController.tryGetValue('maxSupply');\n    }\n}\n"
    },
    "infinitymint/alpha/InfinityMintObject.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//llydia cross 2021\npragma solidity ^0.8.0;\n\n//this is implemented by every contract in our system\nimport './InfinityMintUtil.sol';\nimport './InfinityMintValues.sol';\n\nabstract contract InfinityMintObject {\n    /// @notice The main InfinityMint object, TODO: Work out a way for this to easily be modified\n    struct InfinityObject {\n        uint32 pathId;\n        uint32 currentTokenId;\n        address owner;\n        uint32[] colours;\n        bytes mintData;\n        uint32[] assets;\n        uint32[] names;\n        address[] destinations;\n    }\n\n    /// @notice Creates a new struct from arguments\n    /// @dev Stickers are not set through this, structs cannot be made with sticker contracts already set and have to be set manually\n    /// @param currentTokenId the tokenId,\n    /// @param pathId the infinity mint paths id\n    /// @param assets the assets which make up the token\n    /// @param names the names of the token, its just the name but split by the splaces.\n    /// @param colours decimal colours which will be convered to hexadecimal colours\n    /// @param mintData variable dynamic field which is passed to ERC721 Implementor contracts and used in a lot of dynamic stuff\n    /// @param _sender aka the owner of the token\n    /// @param destinations a list of contracts associated with this token\n    function create(\n        uint32 currentTokenId,\n        uint32 pathId,\n        uint32[] memory assets,\n        uint32[] memory names,\n        uint32[] memory colours,\n        bytes memory mintData,\n        address _sender,\n        address[] memory destinations\n    ) internal pure returns (InfinityObject memory) {\n        return\n            InfinityObject(\n                pathId,\n                currentTokenId,\n                _sender, //the sender aka owner\n                colours,\n                mintData,\n                assets,\n                names,\n                destinations\n            );\n    }\n\n    /// @notice basically unpacks a return object into bytes.\n    function encode(\n        InfinityObject memory data\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encode(\n                data.pathId,\n                data.currentTokenId,\n                data.owner,\n                abi.encode(data.colours),\n                data.mintData,\n                data.assets,\n                data.names,\n                data.destinations\n            );\n    }\n\n    /// @notice Copied behavours of the open zeppelin content due to prevent msg.sender rewrite through assembly\n    function sender() internal view returns (address) {\n        return (msg.sender);\n    }\n\n    /// @notice Copied behavours of the open zeppelin content due to prevent msg.sender rewrite through assembly\n    function value() internal view returns (uint256) {\n        return (msg.value);\n    }\n}\n"
    },
    "infinitymint/alpha/InfinityMintProject.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//llydia cross 2021\npragma solidity ^0.8.0;\n\nimport './Authentication.sol';\n\ncontract InfinityMintProject is InfinityMintObject, Authentication {\n    mapping(uint256 => bytes) internal projects;\n    mapping(uint256 => bytes) internal tags;\n    mapping(bytes => bytes) internal interactions;\n    uint256 internal nextVersion = 0;\n    uint256 internal outputVersion = 0;\n\n    function getVersions() external view returns (uint256) {\n        return nextVersion;\n    }\n\n    function getCurrentTag() external view returns (bytes memory) {\n        return tags[outputVersion];\n    }\n\n    function getCurrentVersion() external view returns (uint256) {\n        return outputVersion;\n    }\n\n    function setInitialProject(bytes memory project) public onlyDeployer {\n        require(nextVersion == 0, 'initial project already set');\n        projects[nextVersion] = project;\n        tags[nextVersion] = 'initial';\n        interactions['initial'] = abi.encode(\n            sender(),\n            block.timestamp,\n            block.number,\n            project.length\n        );\n        outputVersion = 0;\n        unchecked {\n            ++nextVersion;\n        }\n    }\n\n    function setVersion(uint256 version) public onlyApproved {\n        require(version < nextVersion && version > 0, 'invalid version');\n        require(projects[version].length != 0, 'blank project set');\n        outputVersion = version;\n    }\n\n    function getVersion(uint256 version)\n        external\n        view\n        returns (\n            bytes memory encodedProject,\n            bytes memory encodedTag,\n            bytes memory encodedInitialProject\n        )\n    {\n        return (projects[version], tags[version], projects[0]);\n    }\n\n    function getProject() external view returns (bytes memory) {\n        bytes memory result = projects[outputVersion];\n        if (result.length == 0) return bytes(\"{'local':true}\"); //try and force local infinity mint mode\n        return result;\n    }\n\n    function getUpdates() external view returns (bytes[] memory updates) {\n        uint256 count = 0;\n        for (uint256 i = 0; i < nextVersion; ) {\n            if (tags[i].length != 0 && interactions[tags[i]].length != 0)\n                count++;\n\n            unchecked {\n                ++i;\n            }\n        }\n        updates = new bytes[](count);\n        count = 0;\n        for (uint256 i = 0; i < nextVersion; ) {\n            if (tags[i].length != 0 && interactions[tags[i]].length != 0)\n                updates[count++] = interactions[tags[i]];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function updateProject(\n        bytes memory project,\n        bytes memory tag,\n        bool setAsCurrentVersion\n    ) public onlyApproved {\n        require(bytes(project).length != 0, 'blank project set');\n        require(bytes(tag).length != 0, 'blank tag set');\n        require(interactions[tag].length == 0, 'tag already set');\n        require(nextVersion != 0, 'initial project not set by deployer');\n        projects[nextVersion] = project;\n        tags[nextVersion] = tag;\n        interactions[tag] = abi.encode(\n            sender(),\n            block.timestamp,\n            block.number,\n            project.length\n        );\n        unchecked {\n            if (setAsCurrentVersion) outputVersion = nextVersion;\n            ++nextVersion;\n        }\n    }\n}\n"
    },
    "infinitymint/alpha/InfinityMintStorage.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//llydia cross 2021\npragma solidity ^0.8.0;\n\nimport './InfinityMintObject.sol';\nimport './Authentication.sol';\n\n/// @title InfinityMint storage controller\n/// @author Llydia Cross\n/// @notice Stores the outcomes of the mint process and previews and also unlock keys\n/// @dev Attached to to an InfinityMint\ncontract InfinityMintStorage is Authentication, InfinityMintObject {\n    /// @notice previews\n    mapping(address => mapping(uint256 => InfinityObject)) public previews;\n    /// @notice previews timestamps of when new previews can be made\n    mapping(address => uint256) public previewTimestamp;\n    /// @notice all of the token data\n    mapping(uint32 => InfinityObject) private tokens;\n    /// @notice Address flags can be toggled and effect all of the tokens\n    mapping(address => mapping(string => bool)) private flags;\n    /// @notice a list of tokenFlags associated with the token\n    mapping(uint256 => mapping(string => bool)) public tokenFlags;\n    /// @notice a list of options\n    mapping(address => mapping(string => string)) private options;\n    /// @notice private mapping holding a list of tokens for owned by the address for quick look up\n    mapping(address => uint32[]) private registeredTokens;\n\n    /// @notice returns true if the address is preview blocked and unable to receive more previews\n    function getPreviewTimestamp(address addr) external view returns (uint256) {\n        return previewTimestamp[addr];\n    }\n\n    /// @notice sets a time in the future they an have more previews\n    function setPreviewTimestamp(\n        address addr,\n        uint256 timestamp\n    ) public onlyApproved {\n        require(timestamp > block.timestamp, 'timestamp must be in the future');\n        previewTimestamp[addr] = timestamp;\n    }\n\n    /**\n\t\t@notice Returns true if address in destinations array is valid,\n\t\tdestinations array is managed by InfinityMintLinker and i used to associate contract destinations on chain with a token\n\t*/\n    function hasDestinaton(\n        uint32 tokenId,\n        uint256 index\n    ) external view returns (bool) {\n        return\n            tokens[tokenId].destinations.length < index &&\n            tokens[tokenId].destinations[index] != address(0x0);\n    }\n\n    //// @notice Allows the current token owner to toggle a flag on the token, for instance, locked flag being true will mean token cannot be transfered\n    function setTokenFlag(\n        uint256 tokenId,\n        string memory _flag,\n        bool position\n    ) public onlyApproved {\n        require(this.flag(tokenId, 'immutable') != true, 'token is immutable');\n        require(\n            !InfinityMintUtil.isEqual(bytes(_flag), 'immutable'),\n            'token immutable/mutable state cannot be modified this way for security reasons'\n        );\n        tokenFlags[tokenId][_flag] = position;\n    }\n\n    /// @notice returns the value of a flag\n    /// #[exposeFunction]\n    function flag(\n        uint256 tokenId,\n        string memory _flag\n    ) external view returns (bool) {\n        return tokenFlags[tokenId][_flag];\n    }\n\n    // function flag( uint256 tokenId, string memory _flag) external view returns (bool)\n    /// @notice sets an option for a users tokens\n    /// @dev this is used for instance inside of tokenURI\n    function setOption(\n        address addr,\n        string memory key,\n        string memory option\n    ) public onlyApproved {\n        options[addr][key] = option;\n    }\n\n    /// @notice deletes an option\n    function deleteOption(address addr, string memory key) public onlyApproved {\n        delete options[addr][key];\n    }\n\n    /// @notice returns a global option for all the addresses tokens\n    function getOption(\n        address addr,\n        string memory key\n    ) external view returns (string memory) {\n        return options[addr][key];\n    }\n\n    //// @notice Allows the current token owner to toggle a flag on the token, for instance, locked flag being true will mean token cannot be transfered\n    function setFlag(\n        address addr,\n        string memory _flag,\n        bool position\n    ) public onlyApproved {\n        flags[addr][_flag] = position;\n    }\n\n    function tokenFlag(\n        uint32 tokenId,\n        string memory _flag\n    ) external view returns (bool) {\n        return tokenFlags[tokenId][_flag];\n    }\n\n    function validDestination(\n        uint32 tokenId,\n        uint256 index\n    ) external view returns (bool) {\n        return (tokens[tokenId].owner != address(0x0) &&\n            tokens[tokenId].destinations.length != 0 &&\n            index < tokens[tokenId].destinations.length &&\n            tokens[tokenId].destinations[index] != address(0x0));\n    }\n\n    /// @notice returns the value of a flag\n    function flag(\n        address addr,\n        string memory _flag\n    ) external view returns (bool) {\n        return flags[addr][_flag];\n    }\n\n    /// @notice returns address of the owner of this token\n    /// @param tokenId the tokenId to get the owner of\n    function getOwner(uint32 tokenId) public view returns (address) {\n        return tokens[tokenId].owner;\n    }\n\n    /// @notice returns an integer array containing the token ids owned by the owner address\n    /// @dev NOTE: This will only track 256 tokens\n    /// @param owner the owner to look for\n    function getAllRegisteredTokens(\n        address owner\n    ) public view returns (uint32[] memory) {\n        return registeredTokens[owner];\n    }\n\n    /// @notice this method adds a tokenId from the registered tokens list which is kept for the owner. these methods are designed to allow limited data retrival functionality on local host environments\n    /// @dev for local testing purposes mostly, to make it scalable the length is capped to 128. Tokens should be indexed by web2 server not on chain.\n    /// @param owner the owner to add the token too\n    /// @param tokenId the tokenId to add\n    function addToRegisteredTokens(\n        address owner,\n        uint32 tokenId\n    ) public onlyApproved {\n        //if the l\n        if (registeredTokens[owner].length < 256)\n            registeredTokens[owner].push(tokenId);\n    }\n\n    /// @notice Gets the amount of registered tokens\n    /// @dev Tokens are indexable instead by their current positon inside of the owner wallets collection, returns a tokenId\n    /// @param owner the owner to get the length of\n    function getRegisteredTokenCount(\n        address owner\n    ) public view returns (uint256) {\n        return registeredTokens[owner].length;\n    }\n\n    /// @notice returns a token\n    /// @dev returns an InfinityObject defined in {InfinityMintObject}\n    /// @param tokenId the tokenId to get\n    function get(uint32 tokenId) public view returns (InfinityObject memory) {\n        if (tokens[tokenId].owner == address(0x0)) revert('invalid token');\n\n        return tokens[tokenId];\n    }\n\n    /// @notice Sets the owner field in the token to another value\n    function transfer(address to, uint32 tokenId) public onlyApproved {\n        //set to new owner\n        tokens[tokenId].owner = to;\n    }\n\n    function set(\n        uint32 tokenId,\n        InfinityObject memory data\n    ) public onlyApproved {\n        require(data.owner != address(0x0), 'null owner');\n        require(data.currentTokenId == tokenId, 'tokenID mismatch');\n        tokens[tokenId] = data;\n    }\n\n    /// @notice use normal set when can because of the checks it does before the set, this does no checks\n    function setUnsafe(uint32 tokenId, bytes memory data) public onlyApproved {\n        tokens[tokenId] = abi.decode(data, (InfinityObject));\n    }\n\n    function setPreview(\n        address owner,\n        uint256 index,\n        InfinityObject memory data\n    ) public onlyApproved {\n        previews[owner][index] = data;\n    }\n\n    function getPreviewAt(\n        address owner,\n        uint256 index\n    ) external view returns (InfinityObject memory) {\n        require(\n            previews[owner][index].owner != address(0x0),\n            'invalid preview'\n        );\n\n        return previews[owner][index];\n    }\n\n    function findPreviews(\n        address owner,\n        uint256 previewCount\n    ) public view onlyApproved returns (InfinityObject[] memory) {\n        InfinityObject[] memory temp = new InfinityObject[](previewCount);\n        for (uint256 i = 0; i < previewCount; ) {\n            temp[i] = previews[owner][i];\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return temp;\n    }\n\n    function deletePreview(\n        address owner,\n        uint256 previewCount\n    ) public onlyApproved {\n        for (uint256 i = 0; i < previewCount; ) {\n            delete previews[owner][i];\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        delete previewTimestamp[owner];\n    }\n\n    function deleteFromRegisteredTokens(\n        address owner,\n        uint32 tokenId\n    ) public onlyApproved {\n        uint256 length = registeredTokens[owner].length;\n        for (uint256 i = 0; i < length; ) {\n            if (registeredTokens[owner][i] == tokenId) {\n                registeredTokens[owner][i] = registeredTokens[owner][\n                    length - 1\n                ];\n                registeredTokens[owner].pop();\n                break;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "infinitymint/alpha/InfinityMintUtil.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//llydia cross 2021\npragma solidity ^0.8.0;\n\nlibrary InfinityMintUtil {\n    function toString(\n        uint256 _i\n    ) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return '0';\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    //checks if two strings (or bytes) are equal\n    function isEqual(\n        bytes memory s1,\n        bytes memory s2\n    ) internal pure returns (bool) {\n        bytes memory b1 = bytes(s1);\n        bytes memory b2 = bytes(s2);\n        uint256 l1 = b1.length;\n        if (l1 != b2.length) return false;\n        for (uint256 i = 0; i < l1; i++) {\n            //check each byte\n            if (b1[i] != b2[i]) return false;\n        }\n        return true;\n    }\n}\n"
    },
    "infinitymint/alpha/InfinityMintValues.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//llydia cross 2021\npragma solidity ^0.8.0;\n\n/**\n * @title InfinityMintValues\n * @dev This contract is used to store values that are used by the InfinityMint contract.\n * It is used to store the values that are used by the InfinityMint contract.\n */\ncontract InfinityMintValues {\n    mapping(string => uint256) private values;\n    mapping(string => bool) private booleanValues;\n    mapping(string => bool) private registeredValues;\n    mapping(address => bool) public approved;\n\n    address public deployer;\n    /// @notice for re-entry prevention, keeps track of a methods execution count\n    uint256 private executionCount;\n\n    constructor() {\n        deployer = msg.sender;\n        approved[msg.sender] = true;\n        executionCount = 0;\n    }\n\n    event PermissionChange(\n        address indexed sender,\n        address indexed changee,\n        bool value\n    );\n\n    event TransferedOwnership(address indexed from, address indexed to);\n\n    /// @notice Limits execution of a method to once in the given context.\n    /// @dev prevents re-entry attack\n    modifier onlyOnce() {\n        executionCount += 1;\n        uint256 localCounter = executionCount;\n        _;\n        require(localCounter == executionCount, 're-entry');\n    }\n\n    modifier onlyDeployer() {\n        require(deployer == msg.sender, 'not deployer');\n        _;\n    }\n\n    modifier onlyApproved() {\n        require(deployer == msg.sender || approved[msg.sender], 'not approved');\n        _;\n    }\n\n    function setPrivilages(address addr, bool value) public onlyDeployer {\n        require(addr != deployer, 'cannot modify deployer');\n        approved[addr] = value;\n\n        emit PermissionChange(msg.sender, addr, value);\n    }\n\n    function multiApprove(address[] memory addrs) public onlyDeployer {\n        require(addrs.length != 0);\n        for (uint256 i = 0; i < addrs.length; ) {\n            approved[addrs[i]] = true;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function multiRevoke(address[] memory addrs) public onlyDeployer {\n        require(addrs.length != 0);\n        for (uint256 i = 0; i < addrs.length; ) {\n            approved[addrs[i]] = false;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function isAuthenticated(address addr) external view returns (bool) {\n        return addr == deployer || approved[addr];\n    }\n\n    function transferOwnership(address addr) public onlyDeployer {\n        approved[deployer] = false;\n        deployer = addr;\n        approved[addr] = true;\n\n        emit TransferedOwnership(msg.sender, addr);\n    }\n\n    function setValue(string memory key, uint256 value) public onlyDeployer {\n        values[key] = value;\n        registeredValues[key] = true;\n    }\n\n    function setValues(\n        string[] memory keys,\n        uint256[] memory _values\n    ) public onlyDeployer {\n        require(keys.length == _values.length);\n        for (uint256 i = 0; i < keys.length; i++) {\n            setValue(keys[i], _values[i]);\n        }\n    }\n\n    function setBooleanValues(\n        string[] memory keys,\n        bool[] memory _values\n    ) public onlyDeployer {\n        require(keys.length == _values.length);\n        for (uint256 i = 0; i < keys.length; i++) {\n            setBooleanValue(keys[i], _values[i]);\n        }\n    }\n\n    function setupValues(\n        string[] memory keys,\n        uint256[] memory _values,\n        string[] memory booleanKeys,\n        bool[] memory _booleanValues\n    ) public onlyDeployer {\n        require(keys.length == _values.length);\n        require(booleanKeys.length == _booleanValues.length);\n        for (uint256 i = 0; i < keys.length; i++) {\n            setValue(keys[i], _values[i]);\n        }\n\n        for (uint256 i = 0; i < booleanKeys.length; i++) {\n            setBooleanValue(booleanKeys[i], _booleanValues[i]);\n        }\n    }\n\n    function setBooleanValue(\n        string memory key,\n        bool value\n    ) public onlyDeployer {\n        booleanValues[key] = value;\n        registeredValues[key] = true;\n    }\n\n    function isTrue(string memory key) external view returns (bool) {\n        return booleanValues[key];\n    }\n\n    function getValue(string memory key) external view returns (uint256) {\n        if (!registeredValues[key]) revert('Invalid Value');\n\n        return values[key];\n    }\n\n    /// @dev Default value it returns is zero\n    function tryGetValue(string memory key) external view returns (uint256) {\n        if (!registeredValues[key]) return 0;\n\n        return values[key];\n    }\n}\n"
    },
    "infinitymint/alpha/Minter.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//llydia cross 2021\npragma solidity ^0.8.0;\n\nimport './Authentication.sol';\nimport './InfinityMintStorage.sol';\nimport './Asset.sol';\nimport './RandomNumber.sol';\nimport './InfinityMintObject.sol';\n\n/// @title Minter Interface\n/// @author Llydia Cross\n/// @notice The purpose of this interface is to lay the foundation for a minter contract designed to produce a valid InfinityObject at the end of it\n/// @dev\nabstract contract Minter is Authentication {\n    Asset public assetController;\n    InfinityMintValues public valuesController;\n    InfinityMintStorage public storageController;\n    RandomNumber public randomNumberController;\n\n    /*\n     */\n    constructor(\n        address valuesContract,\n        address storageContract,\n        address assetContract,\n        address randomNumberContract\n    ) {\n        valuesController = InfinityMintValues(valuesContract);\n        storageController = InfinityMintStorage(storageContract);\n        assetController = Asset(assetContract);\n        randomNumberController = RandomNumber(randomNumberContract);\n    }\n\n    function setAssetController(address assetContract) public onlyApproved {\n        assetController = Asset(assetContract);\n    }\n\n    function setStorageController(address storageContract) public onlyApproved {\n        storageController = InfinityMintStorage(storageContract);\n    }\n\n    function setRandomNumberController(address randomNumberContract)\n        public\n        onlyApproved\n    {\n        randomNumberController = RandomNumber(randomNumberContract);\n    }\n\n    function mint(\n        uint32 currentTokenId,\n        address sender,\n        bytes memory mintData\n    ) public virtual returns (InfinityMintObject.InfinityObject memory);\n\n    /**\n\n     */\n    function getPreview(uint32 currentTokenId, address sender)\n        external\n        virtual\n        returns (uint256 previewCount);\n\n    /*\n\n    */\n    function mintPreview(\n        uint32 index,\n        uint32 currentTokenId,\n        address sender\n    ) external virtual returns (InfinityMintObject.InfinityObject memory);\n}\n"
    },
    "infinitymint/alpha/RandomNumber.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//llydia cross 2021\npragma solidity ^0.8.0;\n\nimport './InfinityMintValues.sol';\n\n/// @title InfinityMint Random Number Abstract Contract\n/// @author Llydia Cross\nabstract contract RandomNumber {\n    uint256 public randomnessFactor;\n    bool public hasDeployed = false;\n    uint256 public salt = 1;\n\n    InfinityMintValues internal valuesController;\n\n    constructor(address valuesContract) {\n        valuesController = InfinityMintValues(valuesContract);\n        randomnessFactor = valuesController.tryGetValue('randomessFactor');\n    }\n\n    function getNumber() external returns (uint256) {\n        unchecked {\n            ++salt;\n        }\n\n        return\n            unsafeNumber(valuesController.tryGetValue('maxRandomNumber'), salt);\n    }\n\n    function getMaxNumber(uint256 maxNumber) external returns (uint256) {\n        unchecked {\n            ++salt;\n        }\n\n        return unsafeNumber(maxNumber, salt);\n    }\n\n    /// @notice cheap return number\n    function unsafeNumber(uint256 maxNumber, uint256 _salt)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        if (maxNumber <= 0) maxNumber = 1;\n        return (_salt + salt + block.timestamp) % maxNumber;\n    }\n}\n"
    },
    "infinitymint/alpha/Royalty.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n//llydia cross 2021\npragma solidity ^0.8.0;\n\nimport './Authentication.sol';\n\n/// @title InfinityMint Royalty Abstract Contract\n/// @author Llydia Cross\nabstract contract Royalty is Authentication {\n    //globals\n    InfinityMintValues internal valuesController;\n    address public erc721Destination;\n\n    //payout values\n    mapping(address => uint256) public values;\n    mapping(uint256 => uint256) public freebies;\n\n    uint256 public tokenPrice;\n    uint256 public originalTokenPrice;\n    uint256 public lastTokenPrice;\n    uint256 public stickerSplit;\n\n    uint8 public constant SPLIT_TYPE_MINT = 0;\n    uint8 public constant SPLIT_TYPE_STICKER = 1;\n\n    uint256 internal remainder;\n\n    event DispensedRoyalty(\n        address indexed sender,\n        uint256 amount,\n        uint256 newTotal\n    );\n\n    constructor(address valuesContract) {\n        valuesController = InfinityMintValues(valuesContract);\n\n        tokenPrice =\n            valuesController.tryGetValue('startingPrice') *\n            valuesController.tryGetValue('baseTokenValue');\n        lastTokenPrice =\n            valuesController.tryGetValue('startingPrice') *\n            valuesController.tryGetValue('baseTokenValue');\n        originalTokenPrice =\n            valuesController.tryGetValue('startingPrice') *\n            valuesController.tryGetValue('baseTokenValue');\n\n        if (valuesController.tryGetValue('stickerSplit') > 100)\n            revert('sticker split is a value over 100');\n        stickerSplit = valuesController.tryGetValue('stickerSplit');\n    }\n\n    function changePrice(uint256 _tokenPrice) public onlyDeployer {\n        lastTokenPrice = tokenPrice;\n        tokenPrice = _tokenPrice;\n    }\n\n    function registerFree(uint256 splitType) public onlyApproved {\n        freebies[splitType] = freebies[splitType] + 1;\n    }\n\n    function dispenseRoyalty(\n        address addr\n    ) public onlyApproved onlyOnce returns (uint256 total) {\n        if (values[addr] <= 0) revert('Invalid or Empty address');\n\n        total = values[addr];\n        values[addr] = 0;\n\n        emit DispensedRoyalty(addr, total, values[addr]);\n    }\n\n    function incrementBalance(\n        uint256 value,\n        uint256 typeOfSplit\n    ) external virtual;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 20
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}